import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { Play, Pause, RotateCcw, Volume2, VolumeX, ZoomIn, ZoomOut } from 'lucide-react';

// --- Audio Engine Helper ---
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.gainNode = null;
    this.reverbNode = null;
  }

  init() {
    if (!this.ctx) {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Master Volume
      this.gainNode = this.ctx.createGain();
      this.gainNode.gain.value = 0.15; 
      
      // Reverb (Convolver)
      const sampleRate = this.ctx.sampleRate;
      const length = sampleRate * 2.5;
      const impulse = this.ctx.createBuffer(2, length, sampleRate);
      const left = impulse.getChannelData(0);
      const right = impulse.getChannelData(1);
      for (let i = 0; i < length; i++) {
        const decay = Math.pow(1 - i / length, 2);
        left[i] = (Math.random() * 2 - 1) * decay;
        right[i] = (Math.random() * 2 - 1) * decay;
      }
      this.reverbNode = this.ctx.createConvolver();
      this.reverbNode.buffer = impulse;
      
      this.reverbNode.connect(this.gainNode);
      this.gainNode.connect(this.ctx.destination);
    }
    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }
  }

  playTone(value, stepIndex) {
    if (!this.ctx) return;

    // --- Pitch Logic ---
    // Rise to 10,000, then fall to 100,000
    let frequency;
    const PEAK_STEP = 10000;
    const MAX_STEP = 100000;
    const MIN_FREQ = 80;  // Low bass
    const PEAK_FREQ = 1200; // High clear tone
    
    if (stepIndex <= PEAK_STEP) {
        const t = stepIndex / PEAK_STEP;
        frequency = MIN_FREQ + (PEAK_FREQ - MIN_FREQ) * t;
    } else {
        const t = (stepIndex - PEAK_STEP) / (MAX_STEP - PEAK_STEP);
        const safeT = Math.max(0, Math.min(1, t));
        frequency = PEAK_FREQ - (PEAK_FREQ - MIN_FREQ) * safeT;
    }

    // Texture variation
    const semitoneMod = (value % 12) * 2; 
    frequency += semitoneMod;

    // --- Pan Logic ---
    // Map frequency to stereo field (-0.9 Left to 0.9 Right)
    const panValue = ((frequency - MIN_FREQ) / (PEAK_FREQ - MIN_FREQ)) * 1.8 - 0.9;

    const osc = this.ctx.createOscillator();
    const notePanner = this.ctx.createStereoPanner();
    const envelope = this.ctx.createGain();

    osc.type = stepIndex > PEAK_STEP ? 'triangle' : 'sine';
    osc.frequency.setValueAtTime(frequency, this.ctx.currentTime);
    notePanner.pan.setValueAtTime(panValue, this.ctx.currentTime);

    // Envelope
    envelope.gain.setValueAtTime(0, this.ctx.currentTime);
    envelope.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.01);
    envelope.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);

    osc.connect(envelope);
    envelope.connect(notePanner);
    notePanner.connect(this.reverbNode);
    notePanner.connect(this.gainNode);

    osc.start();
    osc.stop(this.ctx.currentTime + 0.6);
  }
}

const audioEngine = new AudioEngine();

// --- Main Component ---
export default function RecamanVisualizer() {
  const LIMIT_BUFFER = 150000; // Buffer size slightly larger than target
  const TARGET_VALUE = 100000; // Stop condition based on value

  // --- State ---
  const [currentStep, setCurrentStep] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [speedSlider, setSpeedSlider] = useState(30); // 0-100 slider
  const [audioEnabled, setAudioEnabled] = useState(false);
  
  // Viewport State
  const [zoom, setZoom] = useState(5); // Start with a reasonable visible scale
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

  // --- Refs ---
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  
  // --- Logic: Generate Sequence ---
  const sequence = useMemo(() => {
    const seq = new Int32Array(LIMIT_BUFFER + 1);
    const visited = new Set([0]);
    seq[0] = 0;
    let current = 0;

    for (let i = 1; i <= LIMIT_BUFFER; i++) {
      const nextLow = current - i;
      const nextHigh = current + i;

      if (nextLow > 0 && !visited.has(nextLow)) {
        current = nextLow;
      } else {
        current = nextHigh;
      }
      seq[i] = current;
      visited.add(current);
    }
    return seq;
  }, []);

  // --- Animation Loop ---
  const animate = useCallback(() => {
    if (isPlaying) {
      setCurrentStep(prev => {
        // Stop if we hit the end of buffer OR if the value exceeds our target
        if (prev >= LIMIT_BUFFER || sequence[prev] >= TARGET_VALUE) {
          setIsPlaying(false);
          return prev;
        }
        const next = prev + 1;
        if (audioEnabled) {
            audioEngine.playTone(sequence[next], next);
        }
        return next;
      });
    }
  }, [isPlaying, audioEnabled, sequence]);

  useEffect(() => {
    if (isPlaying) {
        // Logarithmic Speed Mapping
        // Slider (0-100) -> Rate (1 - 140 steps/sec)
        // Formula: Rate = Min * (Max/Min)^(Slider/100)
        const minRate = 1;
        const maxRate = 140;
        const rate = minRate * Math.pow(maxRate / minRate, speedSlider / 100);
        const delay = 1000 / rate;

        const interval = setInterval(animate, delay);
        return () => clearInterval(interval);
    }
  }, [isPlaying, speedSlider, animate]);

  // --- Canvas Drawing ---
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d', { alpha: false });
    const container = containerRef.current;
    
    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    
    if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
    } else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    
    const width = rect.width;
    const height = rect.height;
    const centerY = height / 2 + offset.y;
    
    // Fixed scale logic: 1 unit = 1 pixel * zoom
    // This ensures the visualization grows instead of shrinking the world
    const unit = zoom; 
    const startX = (width * 0.1) + offset.x; // Start 10% from left + pan offset

    // Clear
    ctx.fillStyle = '#111827';
    ctx.fillRect(0,0, width, height);

    // Draw Number Line
    ctx.beginPath();
    ctx.strokeStyle = '#374151';
    ctx.lineWidth = 1;
    ctx.moveTo(0, centerY);
    ctx.lineTo(width, centerY);
    ctx.stroke();

    // Draw Arcs - WITH CULLING
    const viewLeft = -500; 
    const viewRight = width + 500;

    // Style config
    ctx.lineWidth = Math.max(1, 2 * Math.sqrt(zoom / 5)); // Thinner lines if zoomed way out

    // We iterate only up to currentStep
    for (let i = 1; i <= currentStep; i++) {
      const prev = sequence[i-1];
      const curr = sequence[i];
      
      const centerVal = (prev + curr) / 2;
      const radiusVal = Math.abs(curr - prev) / 2;
      
      const screenCenter = startX + centerVal * unit;
      const screenRadius = radiusVal * unit;

      // Culling
      if ((screenCenter + screenRadius) < viewLeft || (screenCenter - screenRadius) > viewRight) {
          continue; 
      }
      
      // Detail Culling
      if (screenRadius < 0.5) continue;

      ctx.beginPath();
      const counterClockwise = i % 2 !== 0; 
      
      const hue = (i * 2) % 360;
      ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.8)`;

      ctx.arc(screenCenter, centerY, screenRadius, 0, Math.PI, counterClockwise);
      ctx.stroke();
    }

    // Draw Head Indicator
    if (currentStep > 0) {
      const currentVal = sequence[currentStep];
      const screenX = startX + currentVal * unit;
      
      // Draw dot
      ctx.beginPath();
      ctx.arc(screenX, centerY, Math.max(3, 4 * (zoom/5)), 0, Math.PI * 2); // Scale dot slightly with zoom
      ctx.fillStyle = '#fff';
      ctx.fill();
      
      // Draw text label if enough space
      if (zoom > 2) {
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.fillText(currentVal, screenX, centerY + (currentStep % 2 !== 0 ? -15 : 25));
      }
    }

  }, [currentStep, sequence, zoom, offset]);


  // --- Interaction Handlers ---
  const handleAudioToggle = () => {
    if (!audioEnabled) {
      audioEngine.init();
    }
    setAudioEnabled(!audioEnabled);
  };

  const reset = () => {
    setIsPlaying(false);
    setCurrentStep(0);
    setOffset({x:0, y:0});
    // Don't reset zoom, user might like their setting
  };

  const handleMouseDown = (e) => {
    setIsDragging(true);
    setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
  };

  const handleMouseMove = (e) => {
    if (isDragging) {
      setOffset({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const handleWheel = (e) => {
    const zoomSensitivity = 0.001;
    const delta = -e.deltaY * zoomSensitivity;
    setZoom(z => Math.max(0.01, Math.min(100, z * (1 + delta))));
  };

  return (
    <div className="flex flex-col h-screen w-full bg-gray-900 text-white font-sans overflow-hidden">
      
      {/* Header */}
      <header className="flex-none p-4 border-b border-gray-800 flex justify-between items-center bg-gray-950 z-10">
        <div>
          <h1 className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
            Recam√°n's Sequence
          </h1>
          <p className="text-xs text-gray-400 hidden sm:block">
            Target Value: {TARGET_VALUE.toLocaleString()}
          </p>
        </div>
        
        <div className="flex items-center gap-4">
           {/* Zoom Controls */}
           <div className="flex items-center gap-2 bg-gray-800 rounded-lg p-1">
             <button 
                onClick={() => setZoom(z => Math.max(0.01, z / 1.2))}
                className="p-2 hover:bg-gray-700 rounded-md transition-colors"
                title="Zoom Out"
             >
                <ZoomOut size={18} />
             </button>
             <button 
                onClick={() => setZoom(z => Math.min(100, z * 1.2))}
                className="p-2 hover:bg-gray-700 rounded-md transition-colors"
                title="Zoom In"
             >
                <ZoomIn size={18} />
             </button>
           </div>

           <button
            onClick={handleAudioToggle}
            className={`p-2 rounded-lg transition-all ${audioEnabled ? 'bg-indigo-600 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}
            title={audioEnabled ? "Audio On (Stereo)" : "Enable Audio"}
          >
            {audioEnabled ? <Volume2 size={20} /> : <VolumeX size={20} />}
          </button>
        </div>
      </header>

      {/* Main Canvas Area */}
      <main 
        ref={containerRef} 
        className="flex-1 relative cursor-move overflow-hidden bg-gray-900"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
      >
        <canvas 
            ref={canvasRef} 
            className="absolute top-0 left-0 w-full h-full block"
        />
        
        {/* Overlay Stats */}
        <div className="absolute top-4 right-4 bg-gray-950/80 backdrop-blur px-4 py-2 rounded border border-gray-800 pointer-events-none select-none">
            <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-right">
                <div className="text-xs text-gray-500 uppercase">Step</div>
                <div className="text-xl font-mono font-bold text-white">{currentStep.toLocaleString()}</div>
                
                <div className="text-xs text-gray-500 uppercase">Value</div>
                <div className="text-lg font-mono text-blue-400">{sequence[currentStep]?.toLocaleString()}</div>
            </div>
        </div>
      </main>

      {/* Controls Footer */}
      <footer className="flex-none bg-gray-950 border-t border-gray-800 p-4 sm:p-6 z-10">
        <div className="max-w-2xl mx-auto flex flex-col gap-6">
            
            <div className="flex items-center justify-center gap-8">
                <button 
                    onClick={reset}
                    className="p-3 rounded-full bg-gray-800 hover:bg-gray-700 text-gray-300 transition-all"
                    title="Reset"
                >
                    <RotateCcw size={20} />
                </button>

                <button 
                    onClick={() => {
                        if(!isPlaying && audioEnabled) audioEngine.init();
                        setIsPlaying(!isPlaying);
                    }}
                    className={`w-16 h-16 rounded-full transition-all shadow-lg flex items-center justify-center ${isPlaying ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-blue-500 hover:bg-blue-600 text-white'}`}
                >
                    {isPlaying ? <Pause size={32} fill="currentColor" /> : <Play size={32} fill="currentColor" className="ml-1" />}
                </button>
            </div>

            {/* Speed Control */}
            <div className="flex items-center gap-4 bg-gray-900/50 p-3 rounded-xl border border-gray-800">
                <span className="text-xs text-gray-400 font-medium uppercase w-12">Slow</span>
                <input 
                    type="range" 
                    min="0" 
                    max="100" 
                    value={speedSlider}
                    onChange={(e) => setSpeedSlider(Number(e.target.value))}
                    className="flex-1 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-purple-500"
                />
                <span className="text-xs text-gray-400 font-medium uppercase w-12 text-right">Fast</span>
            </div>
        </div>
      </footer>
    </div>
  );
}