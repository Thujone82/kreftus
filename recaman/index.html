<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Recam치n Sequence Visualizer</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #111827;
            /* Prevent pull-to-refresh and standard scroll behaviors on mobile */
            touch-action: none; 
            overscroll-behavior: none;
        }
        
        /* --- Custom Range Slider Styling --- */
        /* Reset */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%; 
            background: transparent; 
        }

        input[type=range]:focus {
            outline: none; 
        }

        /* WebKit/Blink (Chrome, Edge, Safari) */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #a855f7; /* purple-500 */
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 4px rgba(0,0,0,0.5);
            border: 2px solid #111827; 
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #374151; /* gray-700 */
            border-radius: 2px;
        }

        /* Firefox */
        input[type=range]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border: 2px solid #111827;
            border-radius: 50%;
            background: #a855f7;
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0,0,0,0.5);
        }

        input[type=range]::-moz-range-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #374151;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Icon Components ---
        const IconBase = ({ size = 24, children, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>{children}</svg>
        );

        const Play = (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></IconBase>;
        const Pause = (props) => <IconBase {...props}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></IconBase>;
        const Volume2 = (props) => <IconBase {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></IconBase>;
        const VolumeX = (props) => <IconBase {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></IconBase>;
        const ZoomIn = (props) => <IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>;
        const ZoomOut = (props) => <IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>;
        const Info = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></IconBase>;

        // --- Audio Engine Helper ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.gainNode = null;
                this.reverbNode = null;
            }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.ctx.createGain();
                    this.gainNode.gain.value = 0.15; 
                    
                    const sampleRate = this.ctx.sampleRate;
                    const length = sampleRate * 2.5;
                    const impulse = this.ctx.createBuffer(2, length, sampleRate);
                    const left = impulse.getChannelData(0);
                    const right = impulse.getChannelData(1);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2);
                        left[i] = (Math.random() * 2 - 1) * decay;
                        right[i] = (Math.random() * 2 - 1) * decay;
                    }
                    this.reverbNode = this.ctx.createConvolver();
                    this.reverbNode.buffer = impulse;
                    this.reverbNode.connect(this.gainNode);
                    this.gainNode.connect(this.ctx.destination);
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playTone(value, stepIndex) {
                if (!this.ctx) return;

                let frequency;
                const PEAK_STEP = 10000;
                const MAX_STEP = 100000;
                const MIN_FREQ = 80;
                const PEAK_FREQ = 1200;
                
                if (stepIndex <= PEAK_STEP) {
                    const t = stepIndex / PEAK_STEP;
                    frequency = MIN_FREQ + (PEAK_FREQ - MIN_FREQ) * t;
                } else {
                    const t = (stepIndex - PEAK_STEP) / (MAX_STEP - PEAK_STEP);
                    const safeT = Math.max(0, Math.min(1, t));
                    frequency = PEAK_FREQ - (PEAK_FREQ - MIN_FREQ) * safeT;
                }

                const semitoneMod = (value % 12) * 2; 
                frequency += semitoneMod;

                const panValue = ((frequency - MIN_FREQ) / (PEAK_FREQ - MIN_FREQ)) * 1.8 - 0.9;

                const osc = this.ctx.createOscillator();
                const notePanner = this.ctx.createStereoPanner();
                const envelope = this.ctx.createGain();

                osc.type = stepIndex > PEAK_STEP ? 'triangle' : 'sine';
                osc.frequency.setValueAtTime(frequency, this.ctx.currentTime);
                notePanner.pan.setValueAtTime(panValue, this.ctx.currentTime);

                envelope.gain.setValueAtTime(0, this.ctx.currentTime);
                envelope.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.01);
                envelope.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);

                osc.connect(envelope);
                envelope.connect(notePanner);
                notePanner.connect(this.reverbNode);
                notePanner.connect(this.gainNode);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.6);
            }
        }

        const audioEngine = new AudioEngine();

        // --- Main Component ---
        function RecamanVisualizer() {
            const LIMIT_BUFFER = 150000; 
            const TARGET_VALUE = 100000; 

            // --- State ---
            const [currentStep, setCurrentStep] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [speedSlider, setSpeedSlider] = useState(30);
            const [audioEnabled, setAudioEnabled] = useState(false);
            
            const [isInfoHovered, setIsInfoHovered] = useState(false);
            const [isInfoLocked, setIsInfoLocked] = useState(false);
            
            const [zoom, setZoom] = useState(5);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            
            // Refs for interaction tracking
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const isDraggingRef = useRef(false);
            const lastPosRef = useRef({ x: 0, y: 0 });
            const lastTouchDistRef = useRef(null);

            // --- Logic: Generate Sequence ---
            const sequence = useMemo(() => {
                const seq = new Int32Array(LIMIT_BUFFER + 1);
                const visited = new Set([0]);
                seq[0] = 0;
                let current = 0;

                for (let i = 1; i <= LIMIT_BUFFER; i++) {
                    const nextLow = current - i;
                    const nextHigh = current + i;

                    if (nextLow > 0 && !visited.has(nextLow)) {
                        current = nextLow;
                    } else {
                        current = nextHigh;
                    }
                    seq[i] = current;
                    visited.add(current);
                }
                return seq;
            }, []);

            // --- Animation Loop ---
            const animate = useCallback(() => {
                if (isPlaying) {
                    setCurrentStep(prev => {
                        if (prev >= LIMIT_BUFFER || sequence[prev] >= TARGET_VALUE) {
                            setIsPlaying(false);
                            return prev;
                        }
                        const next = prev + 1;
                        if (audioEnabled) {
                            audioEngine.playTone(sequence[next], next);
                        }
                        return next;
                    });
                }
            }, [isPlaying, audioEnabled, sequence]);

            useEffect(() => {
                if (isPlaying) {
                    const minRate = 1;
                    const maxRate = 140;
                    const rate = minRate * Math.pow(maxRate / minRate, speedSlider / 100);
                    const delay = 1000 / rate;

                    const interval = setInterval(animate, delay);
                    return () => clearInterval(interval);
                }
            }, [isPlaying, speedSlider, animate]);

            // --- Helper: Clamp Offset ---
            const clampOffset = (newOffset, containerHeight, containerWidth) => {
                // 1. Vertical Bounds: Keep the center line within the viewport
                // centerY = height/2 + offset.y
                // We want centerY to be within [0, height] roughly
                const maxY = containerHeight / 2; 
                const minY = -containerHeight / 2;
                
                // 2. Horizontal Bounds:
                // startX = width * 0.1 + offset.x
                // We don't want the origin (0) to go TOO far right (off screen)
                // We don't want the origin to go TOO far left (so we lose everything)
                // Let's say '0' cannot be more than width away
                const maxX = containerWidth; 
                // And let's allow panning left quite a bit, but stop eventually
                const minX = -200000; // Arbitrary large number for deep sequences, or dynamic based on max value

                return {
                    x: Math.max(minX, Math.min(maxX, newOffset.x)),
                    y: Math.max(minY, Math.min(maxY, newOffset.y))
                };
            };

            // --- Canvas Drawing ---
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d', { alpha: false });
                const container = containerRef.current;
                
                const dpr = window.devicePixelRatio || 1;
                const rect = container.getBoundingClientRect();
                
                if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
                    canvas.width = rect.width * dpr;
                    canvas.height = rect.height * dpr;
                    ctx.scale(dpr, dpr);
                } else {
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }
                
                const width = rect.width;
                const height = rect.height;
                const centerY = height / 2 + offset.y;
                const unit = zoom; 
                const startX = (width * 0.1) + offset.x;

                // Clear
                ctx.fillStyle = '#111827';
                ctx.fillRect(0,0, width, height);

                // Draw Number Line
                ctx.beginPath();
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 1;
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();

                // Draw Arcs - WITH CULLING
                const viewLeft = -500; 
                const viewRight = width + 500;

                ctx.lineWidth = Math.max(1, 2 * Math.sqrt(zoom / 5)); 

                for (let i = 1; i <= currentStep; i++) {
                    const prev = sequence[i-1];
                    const curr = sequence[i];
                    
                    const centerVal = (prev + curr) / 2;
                    const radiusVal = Math.abs(curr - prev) / 2;
                    
                    const screenCenter = startX + centerVal * unit;
                    const screenRadius = radiusVal * unit;

                    if ((screenCenter + screenRadius) < viewLeft || (screenCenter - screenRadius) > viewRight) {
                        continue; 
                    }
                    
                    if (screenRadius < 0.5) continue;

                    ctx.beginPath();
                    const counterClockwise = i % 2 !== 0; 
                    
                    const hue = (i * 2) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.8)`;

                    ctx.arc(screenCenter, centerY, screenRadius, 0, Math.PI, counterClockwise);
                    ctx.stroke();
                }

                // Draw Head Indicator
                if (currentStep > 0) {
                    const currentVal = sequence[currentStep];
                    const screenX = startX + currentVal * unit;
                    
                    ctx.beginPath();
                    ctx.arc(screenX, centerY, Math.max(3, 4 * (zoom/5)), 0, Math.PI * 2); 
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                    
                    if (zoom > 2) {
                        ctx.font = '12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = '#fff';
                        ctx.fillText(currentVal, screenX, centerY + (currentStep % 2 !== 0 ? -15 : 25));
                    }
                }

            }, [currentStep, sequence, zoom, offset]);


            // --- Interaction Handlers (Mouse & Touch) ---
            
            const handleMouseDown = (e) => {
                isDraggingRef.current = true;
                lastPosRef.current = { x: e.clientX, y: e.clientY };
            };

            const handleMouseMove = (e) => {
                if (isDraggingRef.current) {
                    const dx = e.clientX - lastPosRef.current.x;
                    const dy = e.clientY - lastPosRef.current.y;
                    lastPosRef.current = { x: e.clientX, y: e.clientY };
                    
                    setOffset(prev => clampOffset(
                        { x: prev.x + dx, y: prev.y + dy },
                        containerRef.current.getBoundingClientRect().height,
                        containerRef.current.getBoundingClientRect().width
                    ));
                }
            };

            const handleMouseUp = () => {
                isDraggingRef.current = false;
            };

            // Touch Logic
            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    isDraggingRef.current = true;
                    lastPosRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    // Pinch Start
                    isDraggingRef.current = false; // Stop dragging if pinching
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    lastTouchDistRef.current = dist;
                }
            };

            const handleTouchMove = (e) => {
                // Prevent browser scrolling/zooming if simpler CSS fails
                // e.preventDefault(); 

                if (e.touches.length === 1 && isDraggingRef.current) {
                    const dx = e.touches[0].clientX - lastPosRef.current.x;
                    const dy = e.touches[0].clientY - lastPosRef.current.y;
                    lastPosRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };

                    setOffset(prev => clampOffset(
                        { x: prev.x + dx, y: prev.y + dy },
                        containerRef.current.getBoundingClientRect().height,
                        containerRef.current.getBoundingClientRect().width
                    ));
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    if (lastTouchDistRef.current) {
                        const delta = dist / lastTouchDistRef.current;
                        setZoom(prev => Math.max(0.01, Math.min(100, prev * delta)));
                    }
                    lastTouchDistRef.current = dist;
                }
            };

            const handleTouchEnd = () => {
                isDraggingRef.current = false;
                lastTouchDistRef.current = null;
            };

            const handleWheel = (e) => {
                const zoomSensitivity = 0.001;
                const delta = -e.deltaY * zoomSensitivity;
                setZoom(z => Math.max(0.01, Math.min(100, z * (1 + delta))));
            };

            // Reset
            const reset = () => {
                setIsPlaying(false);
                setCurrentStep(0);
                setOffset({x:0, y:0});
            };
            
            const handleAudioToggle = () => {
                if (!audioEnabled) {
                    audioEngine.init();
                }
                setAudioEnabled(!audioEnabled);
            };

            return (
                <div className="flex flex-col h-screen w-full bg-gray-900 text-white font-sans overflow-hidden">
                
                    {/* Header */}
                    <header className="flex-none p-4 border-b border-gray-800 flex justify-between items-center bg-gray-950 z-10">
                        <div>
                            <h1 className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
                                Recam치n's Sequence
                            </h1>
                            <p className="text-xs text-gray-400 hidden sm:block">
                                Target Value: {TARGET_VALUE.toLocaleString()}
                            </p>
                        </div>
                        
                        <div className="flex items-center gap-4">
                        {/* Info Button */}
                        <div className="relative">
                            <button
                                onMouseEnter={() => setIsInfoHovered(true)}
                                onMouseLeave={() => setIsInfoHovered(false)}
                                onClick={() => setIsInfoLocked(!isInfoLocked)}
                                className={`p-2 rounded-lg transition-colors ${isInfoLocked || isInfoHovered ? 'bg-gray-800 text-white' : 'bg-gray-900 text-gray-400 hover:bg-gray-800'}`}
                                title="About Recam치n's Sequence"
                            >
                                <Info size={20} />
                            </button>
                            
                            {/* Tooltip / Popup */}
                            {(isInfoHovered || isInfoLocked) && (
                                <div className="absolute top-full right-0 mt-4 w-72 p-4 bg-gray-800 border border-gray-700 rounded-xl shadow-2xl z-50 text-sm text-gray-200 backdrop-blur-sm bg-opacity-95">
                                    <h3 className="font-bold text-white mb-2 text-base">The Recam치n Sequence</h3>
                                    <p className="mb-3 text-gray-300 leading-relaxed">
                                        A recursive sequence defined by a simple rule that creates complex behavior:
                                    </p>
                                    <div className="bg-gray-900/50 p-3 rounded-lg border border-gray-700/50 mb-3 font-mono text-xs">
                                        <p className="mb-1"><span className="text-purple-400">a(0)</span> = 0</p>
                                        <p className="mb-1">For step <span className="text-blue-400">n</span>:</p>
                                        <p className="pl-2 text-gray-400">Try <span className="text-green-400">prev - n</span></p>
                                        <p className="pl-2 mb-1">If positive & new, take it.</p>
                                        <p className="pl-2 text-gray-400">Else <span className="text-red-400">prev + n</span></p>
                                    </div>
                                    <p className="text-xs text-gray-500 italic">
                                        Known as "The sequence that wants to die but can't" because it constantly tries to return to zero but is forced outwards.
                                    </p>
                                </div>
                            )}
                        </div>

                        {/* Zoom Controls */}
                        <div className="flex items-center gap-2 bg-gray-800 rounded-lg p-1">
                            <button 
                                onClick={() => setZoom(z => Math.max(0.01, z / 1.2))}
                                className="p-2 hover:bg-gray-700 rounded-md transition-colors"
                                title="Zoom Out"
                            >
                                <ZoomOut size={18} />
                            </button>
                            <button 
                                onClick={() => setZoom(z => Math.min(100, z * 1.2))}
                                className="p-2 hover:bg-gray-700 rounded-md transition-colors"
                                title="Zoom In"
                            >
                                <ZoomIn size={18} />
                            </button>
                        </div>

                        <button
                            onClick={handleAudioToggle}
                            className={`p-2 rounded-lg transition-all ${audioEnabled ? 'bg-indigo-600 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}
                            title={audioEnabled ? "Audio On (Stereo)" : "Enable Audio"}
                        >
                            {audioEnabled ? <Volume2 size={20} /> : <VolumeX size={20} />}
                        </button>
                        </div>
                    </header>

                    {/* Main Canvas Area */}
                    <main 
                        ref={containerRef} 
                        className="flex-1 relative cursor-move overflow-hidden bg-gray-900"
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onWheel={handleWheel}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                    >
                        <canvas 
                            ref={canvasRef} 
                            className="absolute top-0 left-0 w-full h-full block"
                        />
                        
                        {/* Overlay Stats */}
                        <div className="absolute top-4 right-4 bg-gray-950/80 backdrop-blur px-4 py-2 rounded border border-gray-800 pointer-events-none select-none">
                            <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-right">
                                <div className="text-xs text-gray-500 uppercase">Step</div>
                                <div className="text-xl font-mono font-bold text-white">{currentStep.toLocaleString()}</div>
                                
                                <div className="text-xs text-gray-500 uppercase">Value</div>
                                <div className="text-lg font-mono text-blue-400">{sequence[currentStep]?.toLocaleString()}</div>
                            </div>
                        </div>
                    </main>

                    {/* Controls Footer */}
                    <footer className="flex-none bg-gray-950 border-t border-gray-800 p-4 pb-10 sm:p-6 z-10">
                        <div className="max-w-3xl mx-auto flex flex-row items-center gap-4">
                            
                            {/* Buttons */}
                            <div className="flex items-center gap-3 flex-none">
                                <button 
                                    onClick={reset}
                                    className="p-3 rounded-full bg-gray-800 hover:bg-gray-700 text-gray-300 transition-all"
                                    title="Reset"
                                >
                                    <RotateCcw size={20} />
                                </button>

                                <button 
                                    onClick={() => {
                                        if(!isPlaying && audioEnabled) audioEngine.init();
                                        setIsPlaying(!isPlaying);
                                    }}
                                    className={`w-12 h-12 rounded-full transition-all shadow-lg flex items-center justify-center ${isPlaying ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-blue-500 hover:bg-blue-600 text-white'}`}
                                >
                                    {isPlaying ? <Pause size={24} fill="currentColor" /> : <Play size={24} fill="currentColor" className="ml-1" />}
                                </button>
                            </div>

                            {/* Speed Control */}
                            <div className="flex items-center gap-3 bg-gray-900/50 p-2 rounded-xl border border-gray-800 flex-1 min-w-0">
                                <span className="text-xs text-gray-400 font-medium uppercase whitespace-nowrap">Slow</span>
                                <input 
                                    type="range" 
                                    min="0" 
                                    max="100" 
                                    value={speedSlider}
                                    onChange={(e) => setSpeedSlider(Number(e.target.value))}
                                    className="flex-1 h-2 bg-gray-700 rounded-lg cursor-pointer min-w-0"
                                />
                                <span className="text-xs text-gray-400 font-medium uppercase whitespace-nowrap">Fast</span>
                            </div>
                        </div>
                    </footer>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<RecamanVisualizer />);
    </script>
</body>
</html>