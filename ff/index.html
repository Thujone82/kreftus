<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Fire Model (Drossel‚ÄìSchwabl)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0;
            touch-action: none; /* Prevent default touch scrolling to handle swipes manually */
        }

        /* Custom Scrollbar */
        .custom-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 4px;
        }

        canvas {
            image-rendering: pixelated; /* Keeps the grid crisp */
            box-shadow: 0 0 50px rgba(239, 68, 68, 0.15);
            max-width: 100%;
            max-height: 100%;
            cursor: pointer; /* Indicate clickable */
        }
        
        /* Ensure canvas covers screen in fullscreen mode */
        canvas:fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none;
            max-height: none;
        }

        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #38bdf8;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.15s ease-in-out;
        }
        .slider-thumb::-webkit-slider-thumb:hover {
            background: #0ea5e9;
        }
        .slider-thumb::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #38bdf8;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Portrait mode: move canvas to top */
        @media (orientation: portrait) and (max-width: 767px) {
            main {
                order: -1;
            }
            aside {
                order: 0;
            }
        }
    </style>
</head>
<body class="w-screen bg-slate-900 flex flex-col landscape:flex-row md:flex-row h-auto min-h-screen landscape:h-screen md:h-screen landscape:overflow-hidden md:overflow-hidden">

    <!-- Sidebar / Controls -->
    <aside class="w-full landscape:w-80 md:w-80 bg-slate-900 border-b landscape:border-b-0 landscape:border-r md:border-b-0 md:border-r border-slate-700 p-6 flex flex-col z-10 shadow-2xl shrink-0 custom-scroll overflow-y-auto landscape:h-full md:h-full">
        <div class="flex justify-between items-center mb-4 md:mb-6">
            <div>
                <h1 class="text-3xl font-bold mb-1 text-transparent bg-clip-text bg-gradient-to-r from-orange-400 to-red-600">
                    Forest Fire
                </h1>
            </div>
        </div>

        <!-- Stats -->
        <div class="grid grid-cols-3 gap-2 mb-6 text-center shrink-0">
            <div class="bg-slate-800 rounded p-2 border border-slate-700">
                <div class="text-green-500 font-bold text-lg" id="stat-trees">0%</div>
                <div class="text-[10px] text-slate-400 uppercase">Trees</div>
            </div>
            <div class="bg-slate-800 rounded p-2 border border-slate-700">
                <div class="text-orange-500 font-bold text-lg" id="stat-fire">0%</div>
                <div class="text-[10px] text-slate-400 uppercase">Fire (Area)</div>
            </div>
            <div class="bg-slate-800 rounded p-2 border border-slate-700">
                <div class="text-slate-500 font-bold text-lg" id="stat-empty">0%</div>
                <div class="text-[10px] text-slate-400 uppercase">Empty</div>
            </div>
        </div>

        <!-- Top 10 Fires -->
        <div class="mb-6 shrink-0">
            <h2 class="text-sm font-semibold mb-2 text-slate-300">Top 10 Fires</h2>
            <div class="bg-slate-800 rounded border border-slate-700 p-3 h-24 overflow-y-auto custom-scroll">
                <div id="top10-fires" class="text-xs space-y-1">
                    <div class="text-slate-500 text-center py-2">No fires yet</div>
                </div>
            </div>
        </div>

        <!-- Fire Size Distribution -->
        <div class="mb-6 shrink-0">
            <h2 class="text-sm font-semibold mb-2 text-slate-300">Fire Size Distribution</h2>
            <div class="bg-slate-800 rounded border border-slate-700 p-3">
                <div id="fire-distribution" class="flex items-end justify-between gap-1 h-32">
                    <!-- Bars will be inserted here -->
                    <div class="text-slate-500 text-center text-xs w-full">No data yet</div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="space-y-6 flex-grow pr-2">
            
            <!-- Lightning -->
            <div>
                <label class="flex justify-between text-sm font-medium mb-2 text-slate-300">
                    <span>Lightning</span>
                    <span id="val-lightning" class="text-orange-400">Rare</span>
                </label>
                <input type="range" id="input-lightning" min="0" max="100" value="23" class="slider-thumb w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                <p class="text-xs text-slate-500 mt-1">Ignition probability.</p>
            </div>

            <!-- Growth -->
            <div>
                <label class="flex justify-between text-sm font-medium mb-2 text-slate-300">
                    <span>Regrowth</span>
                    <span id="val-growth" class="text-green-400">Steady</span>
                </label>
                <input type="range" id="input-growth" min="0" max="100" value="48" class="slider-thumb w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                <p class="text-xs text-slate-500 mt-1">Tree growth probability.</p>
            </div>

            <!-- Speed -->
            <div>
                <label class="flex justify-between text-sm font-medium mb-2 text-slate-300">
                    <span>Speed</span>
                    <span id="val-speed" class="text-blue-400">60fps</span>
                </label>
                <input type="range" id="input-speed" min="1" max="60" value="60" class="slider-thumb w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
            </div>

            <!-- Buttons -->
            <div class="pt-2 flex gap-3">
                <button id="btn-reset" class="flex-1 bg-slate-700 hover:bg-slate-600 text-white py-3 px-4 rounded transition shadow border border-slate-600 font-medium text-sm">
                    Reset
                </button>
                <button id="btn-pause" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white py-3 px-4 rounded transition shadow font-medium text-sm">
                    Pause
                </button>
            </div>
        </div>
        
        <div class="mt-8 text-[10px] text-slate-500 border-t border-slate-800 pt-4 hidden md:block landscape:block">
            Green: üå≤ &bull; Red: üî• &bull; Black: Empty<br>
            <strong>Controls:</strong><br>
            Click Canvas: Toggle Fullscreen<br>
            ‚¨ÜÔ∏è/‚¨áÔ∏è Arrows or Swipe: Lightning<br>
            ‚¨ÖÔ∏è/‚û°Ô∏è Arrows or Swipe: Regrowth
        </div>
    </aside>

    <!-- Canvas Container -->
    <main class="flex-grow bg-black relative flex items-center justify-center p-4 md:p-8 overflow-hidden w-full h-auto landscape:h-full md:h-full">
        <canvas id="simCanvas"></canvas>
    </main>

<script>
/**
 * Forest Fire Model (Drossel-Schwabl)
 */

const STATE_EMPTY = 0;
const STATE_TREE = 1;
const STATE_BURNING = 2;

// Configuration
const TARGET_CELLS = 768 * 768; // Preserve total cell count ~590k
let gridWidth = 768;
let gridHeight = 768;

// Simulation State
let grid = [];
let nextGrid = [];
let isRunning = true;
let animationId;
let lastFrameTime = 0;

// Lightning Strike Tracking
let strikeIdGrid = [];
let nextStrikeIdGrid = [];
let nextStrikeId = 1;
let strikeCounts = new Map(); // Map<strikeId, count>

// Tree Colors - 8 distinct tree color shades (more visually distinct)
const TREE_COLORS = [
    { r: 122, g: 215, b: 82 },   // Lime green
    { r: 10, g: 160, b: 70 },   // Standard green
    { r: 15, g: 180, b: 80 },   // Bright green
    { r: 20, g: 200, b: 90 },   // Light green
    { r: 185, g: 205, b: 0 },  // Golden yellow
    { r: 5, g: 130, b: 75 },    // Cooler green (more blue)
    { r: 18, g: 170, b: 65 }    // Balanced green
];

let treeGreenGrid = []; // Store tree color index for each tree (0-7, 255 = no tree)
let nextTreeGreenGrid = []; // Double-buffering for tree green shades
let currentTreeColorIndex = 0; // Current active color index (rotates every 15 seconds)

// Initial Parameters (Will be overwritten by slider init)
let probLightning = 0.00001;
let probGrowth = 0.01;
let fpsTarget = 60;
let frameInterval = 1000 / 60;

// DOM Elements
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); 
const valLightning = document.getElementById('val-lightning');
const valGrowth = document.getElementById('val-growth');
const valSpeed = document.getElementById('val-speed');
const btnReset = document.getElementById('btn-reset');
const btnPause = document.getElementById('btn-pause');
const statTrees = document.getElementById('stat-trees');
const statFire = document.getElementById('stat-fire');
const statEmpty = document.getElementById('stat-empty');
const inputLightning = document.getElementById('input-lightning');
const inputGrowth = document.getElementById('input-growth');
const inputSpeed = document.getElementById('input-speed');
const top10Fires = document.getElementById('top10-fires');
const fireDistribution = document.getElementById('fire-distribution');

/**
 * Initialize the Grid
 */
function initGrid() {
    const totalSize = gridWidth * gridHeight;
    grid = new Int8Array(totalSize);
    nextGrid = new Int8Array(totalSize);
    strikeIdGrid = new Int16Array(totalSize);
    nextStrikeIdGrid = new Int16Array(totalSize);
    treeGreenGrid = new Uint8Array(totalSize);
    nextTreeGreenGrid = new Uint8Array(totalSize);
    nextStrikeId = 1;
    strikeCounts.clear();
    
    // Start with random trees
    for (let i = 0; i < grid.length; i++) {
        // Lower initial density to show off growth
        grid[i] = Math.random() > 0.7 ? STATE_TREE : STATE_EMPTY;
        strikeIdGrid[i] = 0; // No strike ID initially
        // Initialize tree color for existing trees
        if (grid[i] === STATE_TREE) {
            treeGreenGrid[i] = Math.floor(Math.random() * TREE_COLORS.length); // Random color index
        } else {
            treeGreenGrid[i] = 255; // Use 255 as "no tree" marker (valid indices are 0-7)
        }
    }
}

/**
 * Resize canvas dynamically
 */
function resizeCanvas() {
    // If in fullscreen, the CSS handles the visual size (100vw/100vh)
    // We only need to handle logic in the fullscreen change listener
    if (document.fullscreenElement) {
        return;
    }

    const parent = canvas.parentElement;
    const isLandscape = window.matchMedia("(orientation: landscape)").matches;
    const isWide = window.innerWidth >= 768; 

    let size;

    if (isLandscape || isWide) {
        const w = parent.clientWidth - 32;
        const h = parent.clientHeight - 32;
        size = Math.min(w, h);
    } else {
        size = parent.clientWidth - 32;
    }

    size = Math.max(size, 100);
    
    // Set Visual Size
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    
    // Ensure square grid in normal mode
    if (gridWidth !== 768 || gridHeight !== 768) {
        gridWidth = 768;
        gridHeight = 768;
        initGrid();
    }
    
    canvas.width = gridWidth;
    canvas.height = gridHeight;
    
    draw();
}

/**
 * Fullscreen Logic
 */
canvas.addEventListener('click', toggleFullScreen);

function toggleFullScreen() {
    if (!document.fullscreenElement) {
        canvas.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else {
        document.exitFullscreen();
    }
}

document.addEventListener('fullscreenchange', () => {
    if (document.fullscreenElement) {
        // Entered fullscreen: Recalculate grid dimensions
        const ratio = window.innerWidth / window.innerHeight;
        
        // Calculate dimensions to maintain approximately TARGET_CELLS
        gridHeight = Math.floor(Math.sqrt(TARGET_CELLS / ratio));
        gridWidth = Math.floor(TARGET_CELLS / gridHeight);
        
        // Update canvas internal resolution
        canvas.width = gridWidth;
        canvas.height = gridHeight;
        
        // Reset grid to fit new aspect ratio
        initGrid();
    } else {
        // Exited fullscreen: Return to square
        resizeCanvas();
    }
    draw();
});

function getIndex(x, y) {
    if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return -1;
    return y * gridWidth + x;
}

function hasBurningNeighbor(x, y) {
    const neighbors = [[0, -1], [0, 1], [-1, 0], [1, 0]];
    for (let [dx, dy] of neighbors) {
        const idx = getIndex(x + dx, y + dy);
        if (idx !== -1 && grid[idx] === STATE_BURNING) {
            return true;
        }
    }
    return false;
}

function getBurningNeighborStrikeId(x, y) {
    const neighbors = [[0, -1], [0, 1], [-1, 0], [1, 0]];
    for (let [dx, dy] of neighbors) {
        const idx = getIndex(x + dx, y + dy);
        if (idx !== -1 && grid[idx] === STATE_BURNING) {
            return strikeIdGrid[idx];
        }
    }
    return 0;
}

/**
 * Main Update Loop
 */
function update() {
    let trees = 0;
    let fires = 0;
    let empty = 0;

    for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
            const i = y * gridWidth + x;
            const state = grid[i];
            const currentStrikeId = strikeIdGrid[i];

            if (state === STATE_BURNING) {
                nextGrid[i] = STATE_EMPTY;
                nextStrikeIdGrid[i] = 0;
                nextTreeGreenGrid[i] = 255; // Clear tree color (no tree marker)
                
                // Increment count for this strike when fire extinguishes
                if (currentStrikeId > 0) {
                    strikeCounts.set(currentStrikeId, (strikeCounts.get(currentStrikeId) || 0) + 1);
                }
            } 
            else if (state === STATE_TREE) {
                const neighborStrikeId = getBurningNeighborStrikeId(x, y);
                if (neighborStrikeId > 0) {
                    // Fire spreads from neighbor - inherit strike ID
                    nextGrid[i] = STATE_BURNING;
                    nextStrikeIdGrid[i] = neighborStrikeId;
                    nextTreeGreenGrid[i] = 255; // Clear tree color when burning
                }
                else if (Math.random() < probLightning) {
                    // Lightning strike - assign new strike ID
                    nextGrid[i] = STATE_BURNING;
                    nextStrikeIdGrid[i] = nextStrikeId++;
                    strikeCounts.set(nextStrikeIdGrid[i], 0); // Initialize count
                    nextTreeGreenGrid[i] = 255; // Clear tree color when burning
                } else {
                    // Tree stays a tree - preserve its color
                    nextGrid[i] = STATE_TREE;
                    nextStrikeIdGrid[i] = 0;
                    nextTreeGreenGrid[i] = treeGreenGrid[i]; // Preserve existing color
                }
            } 
            else if (state === STATE_EMPTY) {
                if (Math.random() < probGrowth) {
                    // New tree grows - assign current active color
                    nextGrid[i] = STATE_TREE;
                    nextTreeGreenGrid[i] = currentTreeColorIndex; // Use current active color
                } else {
                    nextGrid[i] = STATE_EMPTY;
                    nextTreeGreenGrid[i] = 255; // No tree marker
                }
                nextStrikeIdGrid[i] = 0;
            }
            
            // Count stats for the NEXT frame to be accurate
            if (nextGrid[i] === STATE_TREE) trees++;
            else if (nextGrid[i] === STATE_EMPTY) empty++;
        }
    }

    const temp = grid;
    grid = nextGrid;
    nextGrid = temp;
    
    const tempStrike = strikeIdGrid;
    strikeIdGrid = nextStrikeIdGrid;
    nextStrikeIdGrid = tempStrike;
    
    const tempGreen = treeGreenGrid;
    treeGreenGrid = nextTreeGreenGrid;
    nextTreeGreenGrid = tempGreen;

    // Update UI occasionally
    if (Math.random() < 0.1) {
        const total = gridWidth * gridHeight;
        statTrees.textContent = Math.round((trees / total) * 100) + '%';
        statEmpty.textContent = Math.round((empty / total) * 100) + '%';

        // NEW FIRE CALCULATION: 10x10 Grid Method
        let fireBlocks = 0;
        const regionW = gridWidth / 10; 
        const regionH = gridHeight / 10;

        for (let by = 0; by < 10; by++) {
            for (let bx = 0; bx < 10; bx++) {
                let hasFire = false;
                
                // Calculate pixel bounds for this block
                const startX = Math.floor(bx * regionW);
                const endX = Math.floor((bx + 1) * regionW);
                const startY = Math.floor(by * regionH);
                const endY = Math.floor((by + 1) * regionH);

                // Scan the block in the current 'grid'
                blockLoop:
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        if (grid[y * gridWidth + x] === STATE_BURNING) {
                            hasFire = true;
                            break blockLoop; // Found fire, move to next block
                        }
                    }
                }
                
                if (hasFire) fireBlocks++;
            }
        }
        
        // fireBlocks is already out of 100, so it is the percentage
        statFire.textContent = fireBlocks + '%';
    }
}

/**
 * Draw
 */
function draw() {
    const imageData = ctx.getImageData(0, 0, gridWidth, gridHeight);
    const data = imageData.data;

    for (let i = 0; i < grid.length; i++) {
        const state = grid[i];
        const offset = i * 4;

        if (state === STATE_BURNING) {
            const flicker = Math.random() * 50;
            data[offset] = 255;
            data[offset + 1] = 50 + flicker;
            data[offset + 2] = 0;
            data[offset + 3] = 255;
        } else if (state === STATE_TREE) {
            // Get tree color from stored index
            const colorIndex = treeGreenGrid[i];
            if (colorIndex < TREE_COLORS.length) {
                const treeColor = TREE_COLORS[colorIndex];
                // Add slight random variation for texture
                data[offset] = Math.min(255, Math.max(0, treeColor.r + (Math.random() * 3 - 1.5)));
                data[offset + 1] = Math.min(255, Math.max(0, treeColor.g + (Math.random() * 5 - 2.5)));
                data[offset + 2] = Math.min(255, Math.max(0, treeColor.b + (Math.random() * 3 - 1.5)));
                data[offset + 3] = 255;
            } else {
                // Fallback (shouldn't happen)
                data[offset] = 10;
                data[offset + 1] = 160;
                data[offset + 2] = 70;
                data[offset + 3] = 255;
            }
        } else {
            data[offset] = 15;
            data[offset + 1] = 23;
            data[offset + 2] = 42;
            data[offset + 3] = 255;
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

/**
 * Loop
 */
function loop(timestamp) {
    if (!isRunning) return;
    const elapsed = timestamp - lastFrameTime;
    if (elapsed > frameInterval) {
        lastFrameTime = timestamp - (elapsed % frameInterval);
        update();
        draw();
    }
    animationId = requestAnimationFrame(loop);
}

// ---------------------------------------------------------
// INPUT HANDLERS
// ---------------------------------------------------------

// Lightning Logic:
const LIGHTNING_MAX = 0.0002; 
const LIGHTNING_MIN = 0.000000003;

inputLightning.addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    
    // Power 4 curve + Minimum floor
    probLightning = LIGHTNING_MIN + (Math.pow(val / 100, 4) * (LIGHTNING_MAX - LIGHTNING_MIN));
    
    let text = "Ultra Rare";
    if (val > 25) text = "Rare";
    if (val > 50) text = "Low";
    if (val > 75) text = "Frequent"; 
    valLightning.textContent = text;
});

// Growth Logic:
const GROWTH_MAX = 0.0025; 

inputGrowth.addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    
    // Power 3 curve
    probGrowth = val === 0 ? 0 : Math.pow(val / 100, 3) * GROWTH_MAX;

    let text = "Stagnant";
    if (val > 25) text = "Years";
    if (val > 50) text = "Months";
    if (val > 75) text = "Weeks";
    valGrowth.textContent = text;
});

inputSpeed.addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    fpsTarget = val;
    frameInterval = 1000 / fpsTarget;
    valSpeed.textContent = val + "fps";
});

btnReset.addEventListener('click', () => {
    initGrid();
    draw();
    statTrees.textContent = "0%";
    statFire.textContent = "0%";
    statEmpty.textContent = "0%";
    updateTop10Fires();
    updateFireDistribution();
});

btnPause.addEventListener('click', () => {
    isRunning = !isRunning;
    btnPause.textContent = isRunning ? "Pause" : "Resume";
    btnPause.classList.toggle('bg-blue-600');
    btnPause.classList.toggle('bg-green-600');
    if (isRunning) loop(0);
});

// ---------------------------------------------------------
// KEYBOARD & TOUCH CONTROLS
// ---------------------------------------------------------

const STEP_SIZE = 5; // 1/20th of 100

// Keyboard Inputs
window.addEventListener('keydown', (e) => {
    // Arrow Up/Down -> Lightning
    if (e.key === 'ArrowUp') {
        const newVal = Math.min(100, parseInt(inputLightning.value) + STEP_SIZE);
        inputLightning.value = newVal;
        inputLightning.dispatchEvent(new Event('input')); // Trigger logic
    } 
    else if (e.key === 'ArrowDown') {
        const newVal = Math.max(0, parseInt(inputLightning.value) - STEP_SIZE);
        inputLightning.value = newVal;
        inputLightning.dispatchEvent(new Event('input'));
    }
    // Arrow Left/Right -> Growth
    else if (e.key === 'ArrowRight') {
        const newVal = Math.min(100, parseInt(inputGrowth.value) + STEP_SIZE);
        inputGrowth.value = newVal;
        inputGrowth.dispatchEvent(new Event('input'));
    }
    else if (e.key === 'ArrowLeft') {
        const newVal = Math.max(0, parseInt(inputGrowth.value) - STEP_SIZE);
        inputGrowth.value = newVal;
        inputGrowth.dispatchEvent(new Event('input'));
    }
});

// Touch Inputs
let touchStartX = 0;
let touchStartY = 0;

document.addEventListener('touchstart', (e) => {
    // Don't interfere if user is using sliders
    if (e.target.tagName === 'INPUT') return;
    
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
}, {passive: false});

document.addEventListener('touchend', (e) => {
    if (e.target.tagName === 'INPUT') return;

    const touchEndX = e.changedTouches[0].screenX;
    const touchEndY = e.changedTouches[0].screenY;
    
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    
    // We removed the manual tap detection here.
    // We rely on the standard 'click' event (added above) for Taps/Clicks 
    // to toggle fullscreen. This is safer on mobile as it handles sloppy taps better.
    
    // Swipe Logic (> 30px move)
    if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal Swipe (Growth)
        if (Math.abs(dx) > 30) { 
            if (dx > 0) {
                // Right
                const newVal = Math.min(100, parseInt(inputGrowth.value) + STEP_SIZE);
                inputGrowth.value = newVal;
            } else {
                // Left
                const newVal = Math.max(0, parseInt(inputGrowth.value) - STEP_SIZE);
                inputGrowth.value = newVal;
            }
            inputGrowth.dispatchEvent(new Event('input'));
        }
    } else {
        // Vertical Swipe (Lightning)
        if (Math.abs(dy) > 30) {
            if (dy < 0) {
                // Up
                const newVal = Math.min(100, parseInt(inputLightning.value) + STEP_SIZE);
                inputLightning.value = newVal;
            } else {
                // Down
                const newVal = Math.max(0, parseInt(inputLightning.value) - STEP_SIZE);
                inputLightning.value = newVal;
            }
            inputLightning.dispatchEvent(new Event('input'));
        }
    }
});

/**
 * Update Top 10 Fires Display
 */
function updateTop10Fires() {
    if (strikeCounts.size === 0) {
        top10Fires.innerHTML = '<div class="text-slate-500 text-center py-2">No fires yet</div>';
        return;
    }
    
    // Convert map to array and sort by count (descending)
    const sorted = Array.from(strikeCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
    
    if (sorted.length === 0) {
        top10Fires.innerHTML = '<div class="text-slate-500 text-center py-2">No fires yet</div>';
        return;
    }
    
    let html = '';
    sorted.forEach(([strikeId, count], index) => {
        const rank = index + 1;
        html += `<div class="flex justify-between items-center py-1 px-2 rounded ${index < 3 ? 'bg-slate-700' : ''}">
            <span class="text-slate-400">#${rank}</span>
            <span class="text-orange-400 font-medium">#${strikeId}</span>
            <span class="text-slate-300">${count.toLocaleString()} trees</span>
        </div>`;
    });
    top10Fires.innerHTML = html;
}

/**
 * Update Fire Size Distribution Display
 */
function updateFireDistribution() {
    if (strikeCounts.size === 0) {
        fireDistribution.innerHTML = '<div class="text-slate-500 text-center text-xs w-full">No data yet</div>';
        return;
    }
    
    // Get all strike counts, excluding 0 and 1 tree fires
    const allCounts = Array.from(strikeCounts.values()).filter(count => count > 1);
    
    if (allCounts.length === 0) {
        fireDistribution.innerHTML = '<div class="text-slate-500 text-center text-xs w-full">No significant fires yet</div>';
        return;
    }
    
    // Find max value
    const maxCount = Math.max(...allCounts);
    
    if (maxCount <= 1) {
        // All remaining strikes are 1 or less (shouldn't happen after filter, but safety check)
        fireDistribution.innerHTML = '<div class="text-slate-500 text-center text-xs w-full">No significant fires yet</div>';
        return;
    }
    
    // Create 10 bins for 10th percentiles (0-10%, 10-20%, ..., 90-100%)
    const bins = new Array(10).fill(0);
    const binSize = maxCount / 10;
    
    // Bin the counts (all counts are > 1 at this point)
    allCounts.forEach(count => {
        if (count >= maxCount) {
            bins[9]++; // Max value goes in the last bin
        } else {
            // Find which bin this count belongs to (0-9)
            // Use Math.min to ensure we don't exceed bin 9
            const binIndex = Math.min(Math.floor(count / binSize), 9);
            bins[binIndex]++;
        }
    });
    
    // Find max bin count for scaling
    const maxBinCount = Math.max(...bins);
    
    // Generate bars with logarithmic scaling
    let html = '';
    bins.forEach((count, index) => {
        // Use logarithmic scale for better visibility of smaller counts
        // Add 1 to avoid log(0) and ensure proper scaling
        const logCount = Math.log10(count + 1);
        const logMax = Math.log10(maxBinCount + 1);
        const heightPercent = maxBinCount > 0 && count > 0 ? (logCount / logMax) * 100 : 0;
        const barHeight = Math.max(heightPercent, 2); // Minimum 2% height for visibility
        
        // Dynamic color based on height (green to yellow to red)
        let color;
        if (heightPercent < 33) {
            // Green to yellow
            const ratio = heightPercent / 33;
            color = `rgb(${Math.floor(34 + ratio * 221)}, ${Math.floor(197 + ratio * 58)}, ${Math.floor(34 - ratio * 34)})`;
        } else if (heightPercent < 66) {
            // Yellow to orange
            const ratio = (heightPercent - 33) / 33;
            color = `rgb(${Math.floor(255 - ratio * 45)}, ${Math.floor(255 - ratio * 100)}, ${Math.floor(0)})`;
        } else {
            // Orange to red
            const ratio = (heightPercent - 66) / 34;
            color = `rgb(${Math.floor(255 - ratio * 0)}, ${Math.floor(140 - ratio * 140)}, ${Math.floor(0)})`;
        }
        
        const percentileLabel = index === 0 ? '0-10%' : `${index * 10}-${(index + 1) * 10}%`;
        html += `<div class="flex flex-col items-center flex-1" style="height: 100%;">
            <div class="flex-1 flex items-end w-full">
                <div class="w-full rounded-t transition-all duration-300" 
                     style="height: ${barHeight}%; background-color: ${color}; min-height: 2px;"
                     title="${percentileLabel}: ${count} fires">
                </div>
            </div>
            <div class="text-[9px] text-slate-500 mt-1 text-center">${index * 10}%</div>
        </div>`;
    });
    
    fireDistribution.innerHTML = html;
}

// Setup
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));
initGrid();

// Initialize scale variables based on slider defaults
probLightning = LIGHTNING_MIN + (Math.pow(inputLightning.value / 100, 4) * (LIGHTNING_MAX - LIGHTNING_MIN));
probGrowth = Math.pow(inputGrowth.value / 100, 3) * GROWTH_MAX;

resizeCanvas(); 
loop(0);

// Update Top 10 Fires list and Fire Size Distribution every 3 seconds
setInterval(() => {
    updateTop10Fires();
    updateFireDistribution();
}, 3000);

/**
 * Rotate active tree color every minute
 */
function rotateTreeColor() {
    // Cycle through all tree colors
    const oldIndex = currentTreeColorIndex;
    currentTreeColorIndex = (currentTreeColorIndex + 1) % TREE_COLORS.length;
    console.log(`Tree color rotated: ${oldIndex} -> ${currentTreeColorIndex} (${TREE_COLORS[currentTreeColorIndex].g} green)`);
}

// Rotate tree color every 15 seconds
setInterval(rotateTreeColor, 15000);

</script>
</body>
</html>