<!--
    Snake VS - A Multiplayer and AI Snake Game
    Version: 1.4

    Game Description:
    Snake VS is a modern take on the classic snake game, offering multiple game modes
    for single-player and multiplayer experiences. Players control a snake, aiming to
    eat food to grow longer while avoiding collisions with themselves, other snakes,
    or (in some modes) the boundaries.

    Game Modes:
    1.  VS AI:
        -   Player 1 (P1) competes against an AI-controlled snake.
        -   The goal is to outlast the AI.
        -   The game speeds up and food changes color as levels increase.
        -   Score is tracked as P1 Wins vs AI Wins.

    2.  2 Player (2P):
        -   Two human players compete on the same device.
        -   Player 1 uses WASD keys. Player 2 uses Arrow keys.
        -   Touch controls are split: P1 controls the bottom half of the screen, P2 controls the top half.
        -   The goal is to outlast the other player.
        -   Score is tracked as P1 Wins vs P2 Wins.

    3.  Battle Royale:
        -   Player 1 (P1) competes against 5 AI-controlled snakes.
        -   The goal is to be the last snake surviving.
        -   When a snake is eliminated, its body turns into food items.
        -   Rankings are displayed at the end of the battle.
        -   An "Exit Battle" button appears if P1 is eliminated but other AIs are still fighting,
            allowing P1 to end the current battle and see the results.

    Controls:
    -   Player 1 (All Modes):
        -   Keyboard: W (Up), A (Left), S (Down), D (Right)
        -   Touch: Swipe on the bottom half of the screen (in 2P mode) or anywhere (in VS AI / Battle Royale).
    -   Player 2 (2P Mode Only):
        -   Keyboard: Arrow Up, Arrow Left, Arrow Down, Arrow Right
        -   Touch: Swipe on the top half of the screen.
    -   Pause/Resume (During Gameplay):
        -   Keyboard: Space Bar
        -   Touch: 4-finger tap on the game canvas.

    AI Types (Battle Royale Mode):
    Each AI snake in Battle Royale mode is assigned one of the following types, influencing its behavior:
    -   Type 1 (Standard): Balanced AI, generally seeks the closest food.
    -   Type 2 (Slightly Erratic): Similar to Type 1, but with a small chance (25%) of making a suboptimal (but still safe) turn if one is available, adding a bit of unpredictability.
    -   Type 3 (Farthest Food Hunter / Player Avoider): Targets the farthest food item. In Battle Royale, it also tries to avoid the human player (P1) if P1's snake is relatively long (length > 5). This can lead to more defensive or evasive maneuvers.
    -   Type 4 (Turn Prioritizer): If a safe turn (left or right) leads to a food item or is nearly as good as going straight, this AI prefers to make that turn over continuing straight, even if straight is slightly more optimal. This can make it appear more "active" or "exploratory."
    -   Type 5 (Directionally Biased): This AI has a randomly assigned preferred turning direction (either left or right). When evaluating moves, it gives a slight preference to turns that match its bias and a slight penalty to turns against its bias. This can lead to more circular or patterned movements.

    Tips & Details:
    -   Canvas Border Color:
        -   In VS AI and 2P modes: The top and left borders of the game canvas match the AI/Player 2's color. The bottom and right borders match Player 1's color. This helps quickly identify which color you (P1) are.
        -   In Battle Royale mode: The top and left borders match the color of the *first* AI snake. The bottom and right borders match Player 1's color.
    -   Leveling Up: In VS AI and 2P modes, collecting 10 food items advances the level, increasing game speed and changing the food color.
    -   Food Spawning: Food items will not spawn directly on a snake's body.
    -   AI Decision Delay: AI snakes have a slight delay in their decision-making process to simulate more natural movement rather than instant reactions.
    -   Touch Controls: A swipe gesture (drag finger and release) determines the snake's next direction. The swipe needs to cover a minimum distance (swipeThreshold) to register.
    -   Color Generation: Snake colors are procedurally generated using HSL color space to ensure a variety of distinct and vibrant colors, especially in Battle Royale.
    -   Food Appearance: Food items are rendered as pulsing circles
    -   Start Animations: Brief visual animations play before 2P and Battle Royale modes start to indicate player colors/sides.

-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snake VS v1.4</title>
    <link rel="manifest" href="./manifest.json"> 
    <meta name="theme-color" content="#0f0f1a">

    <style>
        body, html {
            margin: 0; padding: 0; overflow: hidden;
            height: 100%; width: 100%;
            background-color: #1a1a2e;
            font-family: 'Arial', sans-serif;
            color: #e0e0e0;
        }
        #gameCanvas {
            background-color: #0f0f1a;
            display: none; position: absolute; 
            top: 0; left: 0;
            width: 100%; height: 100%;
            box-sizing: border-box;
            border-width: 3px; border-style: solid;
            border-color: transparent; 
        }
        .screen {
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(26, 26, 46, 0.95); 
            z-index: 10; 
        }
        .screen h1 {
            font-size: clamp(4em, 12vw, 7em); margin-bottom: 30px;
            color: #ff69b4; text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4; 
        }
        .screen h2 { /* Game result text */
            font-size: clamp(2.5em, 8vw, 4.5em); margin-bottom: 20px; 
            color: #00ffea; text-shadow: 0 0 8px #00ffea; 
        }
        #recordText { /* For AI/2P scores */
            font-size: clamp(1.5em, 5vw, 2.5em); 
            color: #c0c0ff; margin-bottom: 30px;
            text-shadow: 0 0 5px #c0c0ff;
            line-height: 1.4;
        }
        #rankingsDisplay { /* For Battle Mode rankings */
            font-size: clamp(1.1em, 3.75vw, 1.8em); /* Approx 50% larger */
            color: #c0c0ff; margin-bottom: 30px;
            text-shadow: 0 0 5px #c0c0ff;
            line-height: 1.4;
        }
        #rankingsDisplay h3 { 
             font-size: 1.2em; 
             margin-bottom: 10px;
        }
        #rankingsDisplay p { margin: 5px 0; }
        #rankingsDisplay .player1-rank { font-size: 1.2em; font-weight: bold; }

        .button-container {
            display: flex; flex-direction: column; 
            gap: 15px; align-items: center; width: 90%; max-width: 600px;
        }
        @media (min-width: 700px) { 
            .button-container { flex-direction: row; justify-content: center; flex-wrap: wrap;}
        }
        .playButton {
            padding: 15px 25px; 
            font-size: clamp(1.2em, 4vw, 1.8em); 
            color: #1a1a2e; background-color: #00ffea; 
            border: none; border-radius: 12px; 
            cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25); 
            min-width: 140px; text-align: center; flex-shrink: 0;
        }
        .playButton:hover { filter: brightness(110%); transform: scale(1.05); }
        .playButton:active { transform: scale(0.95); filter: brightness(90%); }
        #titleScreen { display: flex; }
        #gameOverScreen { display: none; }
        #exitBattleButton {
            position: absolute; top: 20px; right: 20px;
            z-index: 20; display: none; 
        }
    </style>
</head>
<body>
    <div id="titleScreen" class="screen">
        <h1>Snake VS</h1>
        <div class="button-container">
             <button id="playAIButton" class="playButton">VS AI</button>
             <button id="play2PButton" class="playButton">2 Player</button>
             <button id="playBattleButton" class="playButton">Battle Royale</button>
        </div>
    </div>

    <div id="gameOverScreen" class="screen">
        <h2 id="gameResult"></h2>
        <p id="recordText"></p> <div id="rankingsDisplay"></div> <div class="button-container">
            <button id="playAgainButton" class="playButton">Play Again</button>
            <button id="gameOverToAIButton" class="playButton">VS AI</button>
            <button id="gameOverTo2PButton" class="playButton">2 Player</button>
            <button id="gameOverToBattleButton" class="playButton">Battle Royale</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <button id="exitBattleButton" class="playButton">Exit Battle</button>

    <script>
        console.log("SnakeVS Script: Loaded and Running v1.4"); 

        // --- Utility Functions (Defined First) ---
        function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }

        function hslToHex(h, s, l) { 
            s /= 100; l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f_hsl = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            const toHex = x => Math.round(x * 255).toString(16).padStart(2, '0');
            return `#${toHex(f_hsl(0))}${toHex(f_hsl(8))}${toHex(f_hsl(4))}`;
        }

        function generateSnakeColors(count = 2) { 
            const colors = [];
            let baseHue = Math.random() * 360;
            const saturation = 100; const lightness = 60;
            const hueStep = 360 / Math.max(count, 3); 
            for (let i = 0; i < count; i++) {
                const hue = (baseHue + i * hueStep + (Math.random() * (hueStep / 2) - (hueStep / 4))) % 360; 
                colors.push(hslToHex(hue, saturation, lightness));
            }
            return colors;
        }

        function hexToRgb(hex){ 
            if (!hex || typeof hex !== 'string' || hex.length < 4) { return {r:0, g:0, b:0}; } 
            const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
            return{r,g,b};
        }
        
        // DOM Elements 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null; 
        const titleScreen = document.getElementById('titleScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const playAIButton = document.getElementById('playAIButton');
        const play2PButton = document.getElementById('play2PButton');
        const playBattleButton = document.getElementById('playBattleButton');
        const playAgainButton = document.getElementById('playAgainButton');
        const gameOverToAIButton = document.getElementById('gameOverToAIButton');
        const gameOverTo2PButton = document.getElementById('gameOverTo2PButton');
        const gameOverToBattleButton = document.getElementById('gameOverToBattleButton');
        const gameResultText = document.getElementById('gameResult');
        const recordText = document.getElementById('recordText');
        const rankingsDisplay = document.getElementById('rankingsDisplay');
        const titleH1 = document.querySelector('#titleScreen h1');
        const exitBattleButton = document.getElementById('exitBattleButton');

        // Game Settings & State Variables
        let gridSize = 20;
        let tileCountX, tileCountY;
        const baseGameSpeed = 120; 
        let gameSpeed = baseGameSpeed;
        let gameInterval;
        let currentMinFoodItems = 2; 
        const MAX_FOOD_ITEMS_DEFAULT = 2; 
        const MIN_FOOD_ITEMS_BATTLE = 4;
        let currentGameMode = 'AI'; 
        let currentLevel = 1;
        let foodCollectedForLevelUp = 0;
        const FOOD_PER_LEVEL = 10; 
        const LEVEL_SPEED_INCREASE_FACTOR = 0.92; 
        const INITIAL_SPEED_FACTOR = 0.70; 
        const levelFoodColors = ['#FFFF00', '#FFA500', '#32CD32', '#87CEFA', '#FFC0CB', '#E6E6FA', '#FF6347'];
        let p1Wins = 0; 
        let p2Wins = 0; 
        window.activeP1Color = '#00ffea'; 
        window.activeP2Color = '#ff69b4'; 
        window.nextP1Color = null;
        window.nextP2Color = null;
        let battleSnakeColors = [];
        let snakes = []; 
        let isPaused = false;
        let justPausedByTouch = false; // Prevents immediate unpause by lifting one of 4 fingers
        let foods = [];

        // --- Canvas & Grid ---
        function resizeCanvas() { 
            if (!canvas) { console.error("resizeCanvas: Canvas element not found!"); return; }
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            tileCountX = Math.floor(canvas.width / gridSize);
            tileCountY = Math.floor(canvas.height / gridSize);
        }

        // --- Snake Initialization ---
        function createSnakeObject(params) { 
            let snake = {
                body: params.body || [{ x: 0, y: 0 }], dx: params.dx || 0, dy: params.dy || 0,
                color: params.color || '#FFFFFF', trailColor: params.trailColor || 'rgba(255,255,255,0.5)',
                isAlive: true, name: params.name || "Snake", aiType: params.aiType || null, 
                lastDirection: params.lastDirection || { dx: params.dx, dy: params.dy }, directionChangedThisTick: false,
                decisionDelay: 0, decisionThreshold: 1, movesWithoutEating: 0, lastFoodTarget: null, turnHistory: [],
                preferredTurnDirection: params.preferredTurnDirection || null, 
                finalLength: 0, rank: 0,
                ...params 
            };
            if (snake.aiType === 3) {
                snake.committedTargetFood = null; 
            }
            return snake;
        }
        function initializeSnakes() { 
            if (tileCountX === undefined || tileCountY === undefined || tileCountX <= 0 || tileCountY <= 0) {
                resizeCanvas(); 
                if (tileCountX <= 0 || tileCountY <= 0) { console.error("InitializeSnakes: tileCountX/Y still invalid after resize."); return; }
            }
            snakes = []; 
            if (currentGameMode === 'AI' || currentGameMode === '2P') {
                snakes.push(createSnakeObject({ name: "Player 1",
                    body: [{ x: Math.floor(tileCountX / (currentGameMode === 'AI' ? 4 : 2)), y: Math.floor(tileCountY * (currentGameMode === 'AI' ? 1/2 : 3/4)) }],
                    dx: currentGameMode === 'AI' ? 1 : 0, dy: currentGameMode === 'AI' ? 0 : -1,
                    color: window.activeP1Color, trailColor: `rgba(${hexToRgb(window.activeP1Color).r},${hexToRgb(window.activeP1Color).g},${hexToRgb(window.activeP1Color).b},0.5)` }));
                let oP = { color: window.activeP2Color, trailColor: `rgba(${hexToRgb(window.activeP2Color).r},${hexToRgb(window.activeP2Color).g},${hexToRgb(window.activeP2Color).b},0.5)`};
                if (currentGameMode === 'AI') {
                    let aiTypeToSet = 1; 
                    const r = Math.random() * 100; 
                    if(r<50)aiTypeToSet=1; else if(r<62.5)aiTypeToSet=2; else if(r<75)aiTypeToSet=3; else if(r<87.5)aiTypeToSet=4; else aiTypeToSet=5;
                    
                    oP.name = `AI-T${aiTypeToSet}`; 
                    oP.body = [{ x: Math.floor(tileCountX * 3 / 4), y: Math.floor(tileCountY / 2) }];
                    oP.dx = -1; oP.dy = 0; 
                    oP.aiType = aiTypeToSet; 
                    oP.preferredTurnDirection = (aiTypeToSet === 5) ? (Math.random() < 0.5 ? 'left' : 'right') : null;
                } else { 
                    oP.name = "Player 2"; oP.body = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 4) }];
                    oP.dx = 0; oP.dy = 1;
                } snakes.push(createSnakeObject(oP));
            } else if (currentGameMode === 'BATTLE') {
                if (battleSnakeColors.length < 6) battleSnakeColors = generateSnakeColors(6); 
                snakes.push(createSnakeObject({ name: "P1", body: [{ x: Math.floor(tileCountX * 0.25), y: Math.floor(tileCountY * 0.80) }],
                    dx: 0, dy: -1, 
                    color: battleSnakeColors[0], trailColor: `rgba(${hexToRgb(battleSnakeColors[0]).r},${hexToRgb(battleSnakeColors[0]).g},${hexToRgb(battleSnakeColors[0]).b},0.5)`}));
                const aiStarts = [ { x: tileCountX*0.25, y: tileCountY*0.20, dx:1, dy:1, p:"AI TL"}, { x: tileCountX*0.75, y: tileCountY*0.20, dx:-1, dy:1, p:"AI TR"}, { x: tileCountX*0.25, y: tileCountY*0.50, dx:1, dy:0, p:"AI ML"}, { x: tileCountX*0.75, y: tileCountY*0.50, dx:-1, dy:0, p:"AI MR"}, { x: tileCountX*0.75, y: tileCountY*0.80, dx:-1, dy:-1, p:"AI BR"}];
                for (let i=0; i<5; i++) {
                    let type=1; const r=Math.random()*100; if(r<50)type=1; else if(r<62.5)type=2; else if(r<75)type=3; else if(r<87.5)type=4; else type=5;
                    snakes.push(createSnakeObject({ name: `${aiStarts[i].p}_T${type}`, body: [{ x: Math.floor(aiStarts[i].x), y: Math.floor(aiStarts[i].y) }],
                        dx: aiStarts[i].dx, dy: aiStarts[i].dy, color: battleSnakeColors[i+1], trailColor: `rgba(${hexToRgb(battleSnakeColors[i+1]).r},${hexToRgb(battleSnakeColors[i+1]).g},${hexToRgb(battleSnakeColors[i+1]).b},0.5)`,
                        aiType: type, preferredTurnDirection: (type === 5) ? (Math.random() < 0.5 ? 'left' : 'right') : null }));
                }
            }
        }
        
        // --- Game Flow & State ---
        function initGame() { 
            try {
                initializeSnakes(); foods = []; 
                currentLevel = 1; // Reset currentLevel BEFORE placing initial food
                currentMinFoodItems = (currentGameMode === 'BATTLE') ? MIN_FOOD_ITEMS_BATTLE : MAX_FOOD_ITEMS_DEFAULT;
                placeNewFoodItem(); 
                gameSpeed = Math.round(baseGameSpeed / INITIAL_SPEED_FACTOR);
                isPaused = false; // Ensure game starts unpaused

                if(exitBattleButton) exitBattleButton.style.display = 'none'; 
                if (gameInterval) clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, gameSpeed);
            } catch (e) { console.error("CRITICAL ERROR in initGame:", e.message, e.stack, e.name); if(gameInterval) clearInterval(gameInterval); }
        }
        function showBattleStartAnimation(cb) { 
            let startTime = null; const duration = 1000; 
            const p1Color = (snakes[0] && snakes[0].color) ? snakes[0].color : '#FFFFFF'; 
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); 
                const bgY = -canvas.height * progress;
                if(ctx) ctx.fillStyle = p1Color; 
                if(ctx) ctx.fillRect(0, bgY, canvas.width, canvas.height);
                const textFadeStart = 0.2; const textFadeEnd = 0.8; let textAlpha = 0;
                if (progress > textFadeStart && progress < textFadeEnd) textAlpha = Math.min(1, (progress - textFadeStart) / 0.3, (textFadeEnd - progress) / 0.3) ;
                if(ctx) {
                    ctx.font = `bold ${clamp(60, 15, 120)}px Arial`; ctx.textAlign = 'center';
                    ctx.fillStyle = `rgba(255, 255, 255, ${textAlpha})`; 
                    ctx.fillText("P1", canvas.width / 2, canvas.height / 2);
                }
                if (progress < 1) requestAnimationFrame(animate); else if (cb) cb();
            } requestAnimationFrame(animate);
        }
        function show2PStartAnimation(cb) { 
            let startTime = null; const duration = 1000; 
            const pipRadius = Math.min(canvas.width, canvas.height) * 0.04; 
            const pipOffset = pipRadius * 2.5; 
            const p1Color = (snakes[0] && snakes[0].color) ? snakes[0].color : '#00FFEA';
            const p2Color = (snakes[1] && snakes[1].color) ? snakes[1].color : '#FF69B4';
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                if(ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height); 
                    ctx.fillStyle = '#0f0f1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
                    const p1RectCurrentY = canvas.height / 2 + (canvas.height / 2) * progress;
                    ctx.fillStyle = p1Color; ctx.fillRect(0, p1RectCurrentY, canvas.width, canvas.height / 2);
                    ctx.fillStyle = p2Color; ctx.beginPath();
                    ctx.arc(canvas.width / 2, p1RectCurrentY + (canvas.height / 4), pipRadius, 0, Math.PI * 2); ctx.fill();
                    const p2RectCurrentY = -(canvas.height / 2) * progress;
                    ctx.fillStyle = p2Color; ctx.fillRect(0, p2RectCurrentY, canvas.width, canvas.height / 2);
                    ctx.fillStyle = p1Color; ctx.beginPath();
                    ctx.arc(canvas.width / 2 - pipOffset, p2RectCurrentY + (canvas.height / 4), pipRadius, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + pipOffset, p2RectCurrentY + (canvas.height / 4), pipRadius, 0, Math.PI * 2); ctx.fill();
                }
                if (progress < 1) requestAnimationFrame(animate); else if (cb) cb();
            } requestAnimationFrame(animate);
         }
        function gameLoop() { 
            try {
                if (isPaused) return; // Skip game logic if paused
                if (!snakes || snakes.length === 0) { if(gameInterval) clearInterval(gameInterval); return; }
                let aliveSnakes = snakes.filter(s => s && s.isAlive);
                if (currentGameMode === 'BATTLE') {
                    if (snakes[0] && !snakes[0].isAlive && aliveSnakes.length > 0 && exitBattleButton && exitBattleButton.style.display === 'none') exitBattleButton.style.display = 'block';
                    if (aliveSnakes.length <= 1) { endGame(); return; }
                } else { if (aliveSnakes.length < 2) { endGame(); return; } }
                const snakesToUpdate = snakes.filter(s => s && s.isAlive);
                snakesToUpdate.forEach(snake => { if (snake && snake.isAlive) updateSnake(snake); });
                const snakesAfterUpdate = snakes.filter(s => s && s.isAlive);
                snakesAfterUpdate.forEach(snake => {
                    if (snake && snake.isAlive) checkCollisions(snake, snakesAfterUpdate.filter(other => other !== snake && other.isAlive));
                });
                aliveSnakes = snakes.filter(s => s && s.isAlive); 
                if (currentGameMode === 'BATTLE') {
                    if (aliveSnakes.length <= 1) { endGame(); return; }
                    if (snakes[0] && !snakes[0].isAlive && aliveSnakes.length > 0 && exitBattleButton && exitBattleButton.style.display === 'none') exitBattleButton.style.display = 'block';
                } else { if (aliveSnakes.length < 2) { endGame(); return; } }
                drawGame();
            } catch (error) { console.error("CRITICAL ERROR in gameLoop:", error.message, error.stack, error.name); if (gameInterval) clearInterval(gameInterval); }
        }
        function levelUp() { 
            currentLevel++; foodCollectedForLevelUp = 0; 
            gameSpeed = Math.round(gameSpeed * LEVEL_SPEED_INCREASE_FACTOR); 
            if (gameInterval) clearInterval(gameInterval); gameInterval = setInterval(gameLoop, gameSpeed);
            const newFoodColor = levelFoodColors[(currentLevel - 1) % levelFoodColors.length];
            foods.forEach(food => food.color = newFoodColor);
        }
        function updateSnake(snake) { 
            try {
                if (!snake || !snake.body || !snake.body[0]) { if(snake) snake.isAlive = false; return; }
                if (snake.aiType && (currentGameMode === 'BATTLE' || (currentGameMode === 'AI' && snake === snakes[1]))) {
                    snake.decisionDelay++;
                    if (snake.decisionDelay >= snake.decisionThreshold) { snake.decisionDelay = 0; decideAIMove(snake, snakes.filter(s => s && s.isAlive)); }
                }
                let head = { x: snake.body[0].x + snake.dx, y: snake.body[0].y + snake.dy };
                if (head.x < 0) head.x = tileCountX - 1; else if (head.x >= tileCountX) head.x = 0;
                if (head.y < 0) head.y = tileCountY - 1; else if (head.y >= tileCountY) head.y = 0;
                snake.body.unshift(head);
                const eatenFoodIndex = foods.findIndex(f => head.x === f.x && head.y === f.y);
                if (eatenFoodIndex > -1) {
                    foods.splice(eatenFoodIndex, 1); foodCollectedForLevelUp++;
                    if (foodCollectedForLevelUp >= FOOD_PER_LEVEL) levelUp();
                    if (snake.aiType === 3) { snake.committedTargetFood = null; } 
                    if (snake.aiType) { snake.movesWithoutEating = 0; snake.turnHistory = []; }
                    placeNewFoodItem(); 
                } else { snake.body.pop(); if (snake.aiType) snake.movesWithoutEating++; }
                snake.directionChangedThisTick = false; // Reset after move is processed
            } catch (error) { console.error("Error in updateSnake for:", snake ? snake.name : "Unknown", error.message, error.stack); if (snake) snake.isAlive = false; }
        }
        function getTurnType(prevDir, currentDirSuggestion) { 
            if (!prevDir || (prevDir.dx === 0 && prevDir.dy === 0)) return 'U'; 
            if (currentDirSuggestion.dx === prevDir.dx && currentDirSuggestion.dy === prevDir.dy) return 'F'; 
            if (currentDirSuggestion.dx === -prevDir.dx && currentDirSuggestion.dy === -prevDir.dy) return 'B'; 
            const crossProduct = (prevDir.dx * currentDirSuggestion.dy) - (prevDir.dy * currentDirSuggestion.dx);
            if (crossProduct === 1 || (prevDir.dx === 0 && prevDir.dy === 1 && currentDirSuggestion.dx === 1) || (prevDir.dx === 0 && prevDir.dy === -1 && currentDirSuggestion.dx === -1) || (prevDir.dx === 1 && prevDir.dy === 0 && currentDirSuggestion.dy === -1) || (prevDir.dx === -1 && prevDir.dy === 0 && currentDirSuggestion.dy === 1) ) return 'L';
            if (crossProduct === -1 || (prevDir.dx === 0 && prevDir.dy === 1 && currentDirSuggestion.dx === -1) || (prevDir.dx === 0 && prevDir.dy === -1 && currentDirSuggestion.dx === 1) || (prevDir.dx === 1 && prevDir.dy === 0 && currentDirSuggestion.dy === 1) || (prevDir.dx === -1 && prevDir.dy === 0 && currentDirSuggestion.dy === -1) ) return 'R';
            return 'U';
        }
        function decideAIMove(aiSnakeObject, otherAliveSnakes) { 
            const head = aiSnakeObject.body[0];
            let currentTargetFood = null; 
            
            if (foods.length === 0) { aiSnakeObject.dx = aiSnakeObject.lastDirection.dx; aiSnakeObject.dy = aiSnakeObject.lastDirection.dy; return; }

            if (aiSnakeObject.aiType === 3) {
                let committedTargetStillExists = false;
                if (aiSnakeObject.committedTargetFood) {
                    for (const foodItem of foods) {
                        if (foodItem.x === aiSnakeObject.committedTargetFood.x && foodItem.y === aiSnakeObject.committedTargetFood.y) {
                            committedTargetStillExists = true; currentTargetFood = foodItem; break;
                        }
                    }
                }
                if (!committedTargetStillExists) { 
                    aiSnakeObject.committedTargetFood = null; let maxDistance = -1;
                    foods.forEach(f => { let dX = Math.abs(head.x - f.x); if (dX > tileCountX / 2) dX = tileCountX - dX; let dY = Math.abs(head.y - f.y); if (dY > tileCountY / 2) dY = tileCountY - dY; const dist = dX + dY; if (dist > maxDistance) { maxDistance = dist; currentTargetFood = f; } });
                    if (currentTargetFood) aiSnakeObject.committedTargetFood = { ...currentTargetFood }; 
                }
            } else { 
                let minDistance = Infinity;
                foods.forEach(f => { let dX = Math.abs(head.x - f.x); if (dX > tileCountX / 2) dX = tileCountX - dX; let dY = Math.abs(head.y - f.y); if (dY > tileCountY / 2) dY = tileCountY - dY; const dist = dX + dY; if (dist < minDistance) { minDistance = dist; currentTargetFood = f; } });
            }

            if (!currentTargetFood) { aiSnakeObject.dx = aiSnakeObject.lastDirection.dx; aiSnakeObject.dy = aiSnakeObject.lastDirection.dy; return; }
            if (!aiSnakeObject.lastFoodTarget || aiSnakeObject.lastFoodTarget.x !== currentTargetFood.x || aiSnakeObject.lastFoodTarget.y !== currentTargetFood.y) { aiSnakeObject.turnHistory = []; aiSnakeObject.lastFoodTarget = { ...currentTargetFood }; } 
            
            const potentialMoves = [ { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 } ];
            let safeMoves = [];

            for (const move of potentialMoves) {
                if ((aiSnakeObject.dx === -move.dx && aiSnakeObject.dx !== 0) || (aiSnakeObject.dy === -move.dy && aiSnakeObject.dy !== 0)) continue; 
                const nextX = head.x + move.dx; const nextY = head.y + move.dy;
                let checkX = nextX; if (checkX < 0) checkX = tileCountX - 1; else if (checkX >= tileCountX) checkX = 0;
                let checkY = nextY; if (checkY < 0) checkY = tileCountY - 1; else if (checkY >= tileCountY) checkY = 0;
                let isSafe = true;
                for (let i = 0; i < aiSnakeObject.body.length; i++) { if (checkX === aiSnakeObject.body[i].x && checkY === aiSnakeObject.body[i].y) { isSafe = false; break; } }
                if (!isSafe) continue; 
                
                for (const otherSnake of otherAliveSnakes) { 
                    if (otherSnake === aiSnakeObject) continue; 
                    if (aiSnakeObject.aiType === 3 && otherSnake === snakes[0] && snakes[0] && snakes[0].body.length > 5) continue;
                    for (const segment of otherSnake.body) { if (checkX === segment.x && checkY === segment.y) { isSafe = false; break; } } 
                    if (!isSafe) break; 
                }
                if (!isSafe) continue;

                if (isSafe && (aiSnakeObject.aiType === 3 || aiSnakeObject.aiType === 5)) {
                    for (const otherSnake of otherAliveSnakes) {
                        if (otherSnake === aiSnakeObject) continue;
                        if (aiSnakeObject.aiType === 3 && otherSnake === snakes[0] && snakes[0] && snakes[0].body.length > 5) continue; 
                        for (const segment of otherSnake.body) {
                            if (Math.abs(checkX - segment.x) <= 1 && Math.abs(checkY - segment.y) <= 1) { isSafe = false; break; }
                        }
                        if (!isSafe) break;
                    }
                }
                if (!isSafe) continue;
                
                if (isSafe) { 
                    let currentWeight = 1; 
                    if (checkX === currentTargetFood.x && checkY === currentTargetFood.y) { currentWeight += 20000; } 
                    else { 
                        if (head.x === currentTargetFood.x && Math.abs(head.y - currentTargetFood.y) === 1) { if (move.dy === (currentTargetFood.y - head.y) && move.dx === 0) currentWeight += 15000; } 
                        else if (head.y === currentTargetFood.y && Math.abs(head.x - currentTargetFood.x) === 1) { if (move.dx === (currentTargetFood.x - head.x) && move.dy === 0) currentWeight += 15000; }
                        else if (head.x === currentTargetFood.x && move.dx === 0) { if ((currentTargetFood.y > head.y && move.dy === 1) || (currentTargetFood.y < head.y && move.dy === -1)) currentWeight += 5000; } 
                        else if (head.y === currentTargetFood.y && move.dy === 0) { if ((currentTargetFood.x > head.x && move.dx === 1) || (currentTargetFood.x < head.x && move.dx === -1)) currentWeight += 5000; }
                        else if (head.x !== currentTargetFood.x && head.y !== currentTargetFood.y) { if (checkX === currentTargetFood.x && move.dx !==0) currentWeight += 2000; if (checkY === currentTargetFood.y && move.dy !==0) currentWeight += 2000; }
                        if (aiSnakeObject.aiType !== 3) { 
                            let dX_w = Math.abs(checkX - currentTargetFood.x); if (dX_w > tileCountX / 2) dX_w = tileCountX - dX_w;
                            let dY_w = Math.abs(checkY - currentTargetFood.y); if (dY_w > tileCountY / 2) dY_w = tileCountY - dY_w;
                            currentWeight += Math.max(0, Math.floor((tileCountX + tileCountY) / 4) - (dX_w + dY_w)); 
                        }
                    } safeMoves.push({ ...move, weight: currentWeight});
                }            
            }
            let chosenMove;
            if (safeMoves.length > 0) { 
                if (aiSnakeObject.aiType === 5 && aiSnakeObject.preferredTurnDirection) { safeMoves.forEach(m => { const t = getTurnType(aiSnakeObject.lastDirection, m); if (aiSnakeObject.preferredTurnDirection==='left'&&t==='L') m.weight*=1.5; else if (aiSnakeObject.preferredTurnDirection==='right'&&t==='R')m.weight*=1.5; else if((aiSnakeObject.preferredTurnDirection==='left'&&t==='R')||(aiSnakeObject.preferredTurnDirection==='right'&&t==='L'))m.weight*=0.5;});}
                safeMoves.sort((a, b) => b.weight - a.weight); chosenMove = safeMoves[0];
                if (aiSnakeObject.aiType === 4 && chosenMove) { const bestMoveIsStraight = getTurnType(aiSnakeObject.lastDirection, chosenMove) === 'F'; if (bestMoveIsStraight) { for (let i = 1; i < safeMoves.length; i++) { const altMove = safeMoves[i]; const altMoveIsTurn = getTurnType(aiSnakeObject.lastDirection, altMove) === 'L' || getTurnType(aiSnakeObject.lastDirection, altMove) === 'R'; if (altMoveIsTurn && altMove.weight >= chosenMove.weight * 0.8) { chosenMove = altMove; break; }}}}
                if (aiSnakeObject.aiType === 2 && Math.random() < 0.25 && safeMoves.length > 1 && Math.random() < 0.5) chosenMove = safeMoves[1];
            } else { chosenMove = { dx: aiSnakeObject.lastDirection.dx, dy: aiSnakeObject.lastDirection.dy }; }
            const actualTurnType = getTurnType(aiSnakeObject.lastDirection, chosenMove);
            if (actualTurnType !== 'U' && actualTurnType !== 'B') { aiSnakeObject.turnHistory.push(actualTurnType); if (aiSnakeObject.turnHistory.length > 5) aiSnakeObject.turnHistory.shift(); }
            aiSnakeObject.lastDirection = { ...chosenMove }; aiSnakeObject.dx = chosenMove.dx; aiSnakeObject.dy = chosenMove.dy;
        }
        function checkCollisions(snake, otherSnakesArray) { 
            if (!snake || !snake.isAlive) return; 
            const head = snake.body[0];
            for (let i = 1; i < snake.body.length; i++) { 
                if (head.x === snake.body[i].x && head.y === snake.body[i].y) { 
                    snake.isAlive = false; snake.finalLength = snake.body.length; 
                    if(currentGameMode === 'BATTLE') convertToFood(snake); return; 
                } 
            }
            for (const other of otherSnakesArray) {
                if (!other || !other.isAlive || other === snake) continue;
                for (let i = 0; i < other.body.length; i++) {
                    if (head.x === other.body[i].x && head.y === other.body[i].y) {
                        snake.isAlive = false; snake.finalLength = snake.body.length; 
                        if(currentGameMode === 'BATTLE') convertToFood(snake);
                        if (i === 0) { 
                             other.isAlive = false; other.finalLength = other.body.length; 
                             if(currentGameMode === 'BATTLE') convertToFood(other);
                        } return;
                    }
                }
            }
        }
        function convertToFood(deadSnake) { 
            if (!deadSnake || !deadSnake.body) return;
            const foodColor = levelFoodColors[(currentLevel - 1) % levelFoodColors.length];
            deadSnake.body.forEach(segment => {
                if (!foods.some(f => f.x === segment.x && f.y === segment.y)) {
                    foods.push({ x: segment.x, y: segment.y, color: foodColor });
                }
            });
        }
        function placeNewFoodItem() { 
            const targetFoodCount = currentMinFoodItems;
            while (foods.length < targetFoodCount) {
                const foodColor = levelFoodColors[(currentLevel - 1) % levelFoodColors.length];
                let newFood = { x: 0, y: 0, color: foodColor }; 
                let validPosition = false; let attempts = 0; const maxAttempts = tileCountX * tileCountY * 2; 
                while (!validPosition && attempts < maxAttempts) {
                    attempts++; newFood.x = Math.floor(Math.random() * tileCountX); newFood.y = Math.floor(Math.random() * tileCountY);
                    validPosition = true;
                    for (const f of foods) { if (f.x === newFood.x && f.y === newFood.y) { validPosition = false; break; } }
                    if (!validPosition) continue;
                    for (const s_ of snakes) { 
                        if (s_ && s_.isAlive && s_.body) { for (const seg of s_.body) { if (seg.x === newFood.x && seg.y === newFood.y) { validPosition = false; break; } } }
                        if(!validPosition) break;
                    }
                }
                if (validPosition) { foods.push(newFood); } 
                else { console.warn("Could not place new food item after max attempts. Breaking food placement loop."); break; } 
            }
        }
        function drawGame() { 
            try {
                if(!ctx || !canvas) { console.error("drawGame: canvas or ctx not available"); return; }
                ctx.fillStyle='rgba(15,15,26,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
                if (!snakes) return;

                snakes.forEach(snake => {
                    if(snake && snake.isAlive && snake.body && snake.color) { 
                        for(let i=0;i<snake.body.length;i++){
                            const s=snake.body[i],o=Math.max(0.3,1-(i*0.07));
                            ctx.fillStyle= i===0 ? snake.color : `rgba(${hexToRgb(snake.color).r},${hexToRgb(snake.color).g},${hexToRgb(snake.color).b},${o})`;
                            if(i===0){ctx.shadowBlur=15;ctx.shadowColor=snake.color;}
                            // Draw slightly smaller to show grid lines if desired, or full for no lines
                            ctx.fillRect(s.x*gridSize, s.y*gridSize, gridSize - (gridSize > 5 ? 1: 0) , gridSize - (gridSize > 5 ? 1: 0));
                            ctx.shadowBlur=0;
                        }
                    }
                });

                foods.forEach(food => { 
                    const pulseFactor = Math.abs(Math.sin(Date.now() / 200)) * 0.15 + 0.85; // Pulse from 85% to 100%
                    const radius = (gridSize / 2.2) * pulseFactor; // Slightly smaller than half grid for better look
                    const centerX = food.x * gridSize + gridSize / 2;
                    const centerY = food.y * gridSize + gridSize / 2;
                    ctx.fillStyle = food.color; ctx.shadowBlur = 15; ctx.shadowColor = food.color;
                    ctx.beginPath(); ctx.arc(centerX, centerY, Math.max(2, radius), 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                });
            } catch (error) { console.error("Error in drawGame:", error.message, error.stack, error.name); if (gameInterval) clearInterval(gameInterval); }
        }

        // --- Input Handling ---
        function handleKeyDown(e){ 
            const key = e.key.toLowerCase();
            if (!snakes || snakes.length === 0 || !snakes[0]) return;
            if (key === ' ') { // Space bar for pause
                e.preventDefault(); // Prevent page scroll if space is pressed
                togglePauseGame(); return;
            }
            
            const p1 = snakes[0];
            if (p1 && p1.isAlive && !p1.directionChangedThisTick) {
                let moved = false;
                if (key === 'w' && p1.dy === 0) { p1.dx = 0; p1.dy = -1; moved = true; }
                else if (key === 's' && p1.dy === 0) { p1.dx = 0; p1.dy = 1; moved = true; }
                else if (key === 'a' && p1.dx === 0) { p1.dx = -1; p1.dy = 0; moved = true; }
                else if (key === 'd' && p1.dx === 0) { p1.dx = 1; p1.dy = 0; moved = true; }
                else if (currentGameMode === 'AI' || currentGameMode === 'BATTLE') { // Arrow keys for P1 in these modes
                    if (key === 'arrowup' && p1.dy === 0) { p1.dx = 0; p1.dy = -1; moved = true; }
                    else if (key === 'arrowdown' && p1.dy === 0) { p1.dx = 0; p1.dy = 1; moved = true; }
                    else if (key === 'arrowleft' && p1.dx === 0) { p1.dx = -1; p1.dy = 0; moved = true; }
                    else if (key === 'arrowright' && p1.dx === 0) { p1.dx = 1; p1.dy = 0; moved = true; }
                }
                if (moved) p1.directionChangedThisTick = true;
            }

            if (currentGameMode === '2P') {
                if (snakes.length < 2 || !snakes[1]) return;
                const p2 = snakes[1];
                if (p2 && p2.isAlive && !p2.directionChangedThisTick) {
                    let movedP2 = false;
                    if (key === 'arrowup' && p2.dy === 0) { p2.dx = 0; p2.dy = -1; movedP2 = true; }
                    else if (key === 'arrowdown' && p2.dy === 0) { p2.dx = 0; p2.dy = 1; movedP2 = true; }
                    else if (key === 'arrowleft' && p2.dx === 0) { p2.dx = -1; p2.dy = 0; movedP2 = true; }
                    else if (key === 'arrowright' && p2.dx === 0) { p2.dx = 1; p2.dy = 0; movedP2 = true; }
                    if (movedP2) p2.directionChangedThisTick = true;
                }
            }
        }
        let activeTouches = {}; const swipeThreshold=30; 
        if(canvas) canvas.addEventListener('touchstart',function(e){
            e.preventDefault(); 
            // Handle 4-finger tap for pause/unpause
            if (e.touches.length === 4) {
                if (!justPausedByTouch) { // Only toggle if this specific 4-finger gesture hasn't already caused a toggle
                    togglePauseGame();
                    justPausedByTouch = true; // Mark that this 4-finger gesture has been processed for pause/unpause
                }
                // Regardless of whether we toggled, a 4-finger event should not be processed for snake movement.
                return;
            }

            // If not a 4-finger pause/unpause gesture, proceed with snake movement logic
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (currentGameMode === 'AI' && (!snakes[0] || !snakes[0].isAlive)) continue; // Skip this touch if P1 is dead in AI mode
                if (currentGameMode === '2P' && ((!snakes[0] || !snakes[0].isAlive) && (!snakes[1] || !snakes[1].isAlive))) continue; // Skip if both dead in 2P
                if (currentGameMode === 'BATTLE' && (!snakes[0] || !snakes[0].isAlive)) continue; // Skip if P1 is dead in Battle mode
                const touchZonePlayer = (currentGameMode === '2P' && touch.screenY < canvas.height / 2) ? 2 : 1;
                activeTouches[touch.identifier] = { startX: touch.screenX, startY: touch.screenY, player: touchZonePlayer };
            }
        }, {passive:false});
        if(canvas) canvas.addEventListener('touchend',function(e){
            e.preventDefault();
            // Reset justPausedByTouch flag if the 4-finger gesture has ended
            if (e.touches.length < 4 && justPausedByTouch) {
                justPausedByTouch = false;
            }

            for (let i=0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchData = activeTouches[touch.identifier];
                if (touchData) {
                    const deltaX = touch.screenX - touchData.startX;
                    const deltaY = touch.screenY - touchData.startY;
                    let targetSnake;
                    if (currentGameMode === 'AI' || currentGameMode === 'BATTLE') {
                        targetSnake = snakes[0];
                    } else { // 2P mode
                        targetSnake = (touchData.player === 1) ? snakes[0] : snakes[1];
                    }
                    if (targetSnake && targetSnake.isAlive) {
                        handleSwipe(deltaX, deltaY, targetSnake);
                    }
                    delete activeTouches[touch.identifier];
                }
            }
        }, {passive:false});
        function handleSwipe(deltaX, deltaY, snakeToControl){ 
            if (!snakeToControl || !snakeToControl.isAlive || snakeToControl.directionChangedThisTick) return;
            let moved = false;
            if(Math.abs(deltaX)>swipeThreshold||Math.abs(deltaY)>swipeThreshold){ 
                if(Math.abs(deltaX)>Math.abs(deltaY)){ 
                    if(deltaX>0 && snakeToControl.dx===0){snakeToControl.dx=1;snakeToControl.dy=0; moved=true;} 
                    else if(deltaX<0 && snakeToControl.dx===0){snakeToControl.dx=-1;snakeToControl.dy=0; moved=true;} 
                }else{ 
                    if(deltaY>0 && snakeToControl.dy===0){snakeToControl.dx=0;snakeToControl.dy=1; moved=true;} 
                    else if(deltaY<0 && snakeToControl.dy===0){snakeToControl.dx=0;snakeToControl.dy=-1; moved=true;}
                }
            }
            if(moved) snakeToControl.directionChangedThisTick = true;
        }
        
        // --- Game Start/End Flow ---
        function startGame(){ 
            try {
                console.log(`[DEBUG] startGame called. Mode: ${currentGameMode}`); 
                if (!titleScreen || !gameOverScreen || !exitBattleButton || !canvas) { console.error("startGame: Critical UI elements not found!"); return; }
                isPaused = false; // Ensure game starts unpaused
                titleScreen.style.display='none'; gameOverScreen.style.display='none'; if(exitBattleButton) exitBattleButton.style.display = 'none';
                
                if (currentGameMode === 'BATTLE') {
                    battleSnakeColors = generateSnakeColors(6);
                    if (battleSnakeColors.length < 6) { console.error("Failed to generate enough battle colors!"); return; }
                    window.activeP1Color = battleSnakeColors[0]; 
                } else {
                    const standardColors = generateSnakeColors(2);
                    window.activeP1Color = standardColors[0]; window.activeP2Color = standardColors[1];
                }
                if (window.nextP1Color && window.nextP2Color && currentGameMode !== 'BATTLE') {
                     window.activeP1Color = window.nextP1Color; window.activeP2Color = window.nextP2Color;
                } else if (window.nextP1Color && currentGameMode === 'BATTLE' && battleSnakeColors.length > 0) {
                     window.activeP1Color = battleSnakeColors[0]; 
                }
                window.nextP1Color = null; window.nextP2Color = null; 

                if(playAIButton) playAIButton.style.backgroundColor = window.activeP1Color; 
                if(play2PButton) play2PButton.style.backgroundColor = window.activeP1Color; 
                if(playBattleButton) playBattleButton.style.backgroundColor = window.activeP1Color;
                const opponentUIColor = (currentGameMode === 'BATTLE') ? (battleSnakeColors[1] || '#FF69B4') : window.activeP2Color;
                if(titleH1) { titleH1.style.color = opponentUIColor; titleH1.style.textShadow = `0 0 10px ${opponentUIColor}, 0 0 20px ${opponentUIColor}`; }
                
                resizeCanvas(); 
                canvas.style.borderTopColor = opponentUIColor; canvas.style.borderLeftColor = opponentUIColor;
                canvas.style.borderRightColor = window.activeP1Color; canvas.style.borderBottomColor = window.activeP1Color;
                
                snakes = []; 
                if (currentGameMode === '2P') {
                     snakes[0] = { color: window.activeP1Color }; snakes[1] = { color: window.activeP2Color }; // Temp for anim
                     canvas.style.display = 'block'; show2PStartAnimation(() => { initGame(); });
                } else if (currentGameMode === 'BATTLE') {
                     snakes[0] = { color: battleSnakeColors[0] }; // Temp for anim
                     canvas.style.display = 'block'; showBattleStartAnimation(() => { initGame(); });
                }
                else { canvas.style.display = 'block'; initGame(); }
            } catch (e) { console.error("CRITICAL ERROR in startGame:", e.message, e.stack, e.name); if(gameInterval) clearInterval(gameInterval); }
        }
        function togglePauseGame() {
            if (canvas.style.display !== 'block') return; // Only allow pause if game canvas is active

            isPaused = !isPaused;
            if (isPaused) {
                if (gameInterval) clearInterval(gameInterval);
                gameInterval = null; 
                if (ctx && canvas) { // Draw Paused Text
                    ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.font = `bold ${clamp(40, 10, 80)}px Arial`;
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
                }
                console.log("Game Paused");
            } else {
                // Clearing overlay is handled by next gameLoop's drawGame
                if (!gameInterval) gameInterval = setInterval(gameLoop, gameSpeed);
                console.log("Game Resumed");
            }
        }
function endGame(){ 
            try {
                // Prevent multiple calls if game already ended and canvas is hidden
                if (!gameInterval && canvas && canvas.style.display === 'none' && gameOverScreen && gameOverScreen.style.display === 'flex') { 
                    console.log("endGame called but game already seems ended and gameOverScreen is visible.");
                    return; 
                } 

                if (gameInterval) clearInterval(gameInterval); 
                gameInterval = null; 
                isPaused = false; // Game is over, so it's not paused in the playable sense
                
                if(canvas) canvas.style.display='none';
                if(gameOverScreen) gameOverScreen.style.display='flex';
                if(exitBattleButton) exitBattleButton.style.display = 'none';

                // Ensure these elements exist before trying to modify them
                if(recordText) recordText.style.display = 'none'; 
                if(rankingsDisplay) { 
                    rankingsDisplay.style.display = 'none'; 
                    rankingsDisplay.innerHTML = ''; 
                }

                if (currentGameMode === 'BATTLE') {
                    if(snakes && snakes.forEach) {
                        snakes.forEach(s => { 
                            if (s && s.isAlive && s.body) s.finalLength = s.body.length; 
                            // Set finalLength for dead snakes too if not already set
                            else if (s && !s.isAlive && s.finalLength === 0 && s.body) s.finalLength = s.body.length; 
                        }); 
                    }
                    if(snakes && snakes.sort) {
                        snakes.sort((a, b) => { 
                            if (!a && !b) return 0; if (!a) return 1; if (!b) return -1; // Handle null/undefined snakes
                            if (a.isAlive !== b.isAlive) return b.isAlive - a.isAlive; 
                            return b.finalLength - a.finalLength; 
                        });
                    }
                    if(snakes && snakes.forEach) {
                        snakes.forEach((s, index) => { if(s) s.rank = index + 1; });
                    }

                    if(gameResultText) gameResultText.textContent = "Battle Over!";
                    if(rankingsDisplay) {
                        rankingsDisplay.style.display = 'block';
                        let rankingsHTML = "<h3>Rankings:</h3>";
                        if(snakes && snakes.forEach) {
                            snakes.forEach(s => { 
                                if(s) { 
                                    const isP1 = s.name === "P1"; 
                                    rankingsHTML += `<p style="color:${s.color || '#FFFFFF'}; ${isP1 ? 'font-size:1.2em; font-weight:bold;' : ''}"> 
                                                        ${s.rank}. ${s.name || 'Unknown Snake'} (Length: ${s.finalLength || 0}) ${!s.isAlive ? '[Eliminated]' : '[Survived!]'} 
                                                     </p>`; 
                                }
                            });
                        }
                        rankingsDisplay.innerHTML = rankingsHTML;
                    }
                } else { 
                    if(recordText) recordText.style.display = 'block';
                    const p1 = snakes[0]; 
                    const opponent = snakes[1]; // Could be AI or Player 2
                    let p1Alive = p1 && p1.isAlive; 
                    let opponentAlive = opponent && opponent.isAlive;

                    // Determine lengths. If snake is alive, use current body length. If dead, use finalLength if set, else 0.
                    const p1Length = (p1 && p1.isAlive && p1.body) ? p1.body.length : ((p1 && p1.finalLength) ? p1.finalLength : 0);
                    const opponentLength = (opponent && opponent.isAlive && opponent.body) ? opponent.body.length : ((opponent && opponent.finalLength) ? opponent.finalLength : 0);
                    const opponentName = (opponent && opponent.name) ? opponent.name : (currentGameMode === 'AI' ? "AI" : "Player 2");

                    let resultMessage = "";
                    let winnerColor = '#e0e0e0';

                    if (!p1Alive && opponentAlive) { 
                        p2Wins++; 
                        resultMessage = (currentGameMode === 'AI' ? `${opponentName} Wins!` : 'Player 2 Wins!');
                        winnerColor = opponent ? opponent.color : '#FFFFFF';
                    } else if (p1Alive && !opponentAlive) { 
                        p1Wins++; 
                        resultMessage = 'Player 1 Wins!';
                        winnerColor = p1 ? p1.color : '#FFFFFF';
                    } else { 
                        resultMessage = "It's a Tie!";
                        // For a tie, ensure final lengths are captured if not already
                        if (p1 && !p1.isAlive && !p1.finalLength && p1.body) p1.finalLength = p1.body.length;
                        if (opponent && !opponent.isAlive && !opponent.finalLength && opponent.body) opponent.finalLength = opponent.body.length;
                    }

                    if(gameResultText) {
                        gameResultText.textContent = resultMessage;
                        gameResultText.style.color = winnerColor;
                    }
                    if(recordText) { 
                        recordText.innerHTML = `Player 1 (Length: ${p1Length}): ${p1Wins}<br>${opponentName} (Length: ${opponentLength}): ${p2Wins}`; 
                    }
                }
                
                const nextColors = generateSnakeColors(2); 
                window.nextP1Color = nextColors[0]; 
                window.nextP2Color = nextColors[1];
                
                if(playAgainButton) { 
                    playAgainButton.textContent = `Play ${currentGameMode.replace('BATTLE', 'Battle Royale')} Again`; 
                    playAgainButton.style.backgroundColor = window.nextP1Color; 
                }

                // --- Button Visibility Logic ---
                if(gameOverToAIButton) gameOverToAIButton.style.display = 'block';
                if(gameOverTo2PButton) gameOverTo2PButton.style.display = 'block';
                if(gameOverToBattleButton) gameOverToBattleButton.style.display = 'block';

                if (currentGameMode === 'AI' && gameOverToAIButton) {
                    gameOverToAIButton.style.display = 'none';
                } else if (currentGameMode === '2P' && gameOverTo2PButton) {
                    gameOverTo2PButton.style.display = 'none';
                } else if (currentGameMode === 'BATTLE' && gameOverToBattleButton) {
                    gameOverToBattleButton.style.display = 'none';
                }
                // --- End Button Visibility Logic ---
                
                // Style the (now correctly visible) mode-switching buttons
                if(gameOverToAIButton) gameOverToAIButton.style.backgroundColor = window.nextP2Color; 
                if(gameOverTo2PButton) gameOverTo2PButton.style.backgroundColor = window.nextP2Color;
                if(gameOverToBattleButton) gameOverToBattleButton.style.backgroundColor = window.nextP2Color;

            } catch (e) { 
                console.error("CRITICAL ERROR in endGame:", e.message, e.stack, e.name); 
            }
        }
        // --- Event Listeners ---
        console.log("Attaching event listeners...");
        if (playAIButton) playAIButton.addEventListener('click', () => { console.log("--- playAIButton CLICKED ---"); if (currentGameMode !== 'AI' || currentGameMode === 'BATTLE') { p1Wins = 0; p2Wins = 0;} currentGameMode = 'AI'; try { startGame(); } catch (e) { console.error(`[DEBUG] Error in AI button startGame:`, e.message, e.stack, e.name); } }); else console.error("playAIButton not found");
        if (play2PButton) play2PButton.addEventListener('click', () => { console.log("--- play2PButton CLICKED ---"); if (currentGameMode !== '2P' || currentGameMode === 'BATTLE') { p1Wins = 0; p2Wins = 0;} currentGameMode = '2P'; try { startGame(); } catch (e) { console.error(`[DEBUG] Error in 2P button startGame:`, e.message, e.stack, e.name); } }); else console.error("play2PButton not found");
        if (playBattleButton) playBattleButton.addEventListener('click', () => { console.log("--- playBattleButton CLICKED ---"); currentGameMode = 'BATTLE'; try { startGame(); } catch (e) { console.error(`[DEBUG] Error in Battle button startGame:`, e.message, e.stack, e.name); } }); else console.error("playBattleButton not found");
        if (gameOverToAIButton) gameOverToAIButton.addEventListener('click', () => { console.log("--- gameOverToAIButton CLICKED ---"); if (currentGameMode !== 'AI' || currentGameMode === 'BATTLE') { p1Wins = 0; p2Wins = 0;} currentGameMode = 'AI'; try { startGame(); } catch (e) { console.error(`[DEBUG] Error in gameOverToAIButton startGame:`, e.message, e.stack, e.name); } }); else console.error("gameOverToAIButton not found");
        if (gameOverTo2PButton) gameOverTo2PButton.addEventListener('click', () => { console.log("--- gameOverTo2PButton CLICKED ---"); if (currentGameMode !== '2P' || currentGameMode === 'BATTLE') { p1Wins = 0; p2Wins = 0;} currentGameMode = '2P'; try { startGame(); } catch (e) { console.error(`[DEBUG] Error in gameOverTo2PButton startGame:`, e.message, e.stack, e.name); } }); else console.error("gameOverTo2PButton not found");
        if (gameOverToBattleButton) gameOverToBattleButton.addEventListener('click', () => { 
            console.log("--- gameOverToBattleButton CLICKED ---"); 
            // Reset scores if switching from a non-Battle mode, or if P1/P2 scores were being tracked
            if (currentGameMode !== 'BATTLE') { p1Wins = 0; p2Wins = 0; } 
            currentGameMode = 'BATTLE'; 
            try { startGame(); } catch (e) { console.error(`[DEBUG] Error in gameOverToBattleButton startGame:`, e.message, e.stack, e.name); } 
        }); else console.error("gameOverToBattleButton not found");
        if (playAgainButton) playAgainButton.addEventListener('click', () => { console.log("[DEBUG] Play Again clicked."); try { startGame(); } catch (e) { console.error("[DEBUG] Error from Play Again:", e.message, e.stack, e.name); } }); else console.error("playAgainButton not found");
        if (exitBattleButton) exitBattleButton.addEventListener('click', () => { console.log("[DEBUG] Exit Battle clicked."); if (currentGameMode === 'BATTLE' && snakes && snakes.length > 0 && snakes[0] && !snakes[0].isAlive) { try { endGame(); } catch (e) { console.error("[DEBUG] Error from Exit Battle:", e.message, e.stack, e.name); } } else { console.log("[DEBUG] Exit Battle: Conditions not met."); } }); else console.error("exitBattleButton not found");
        
        window.addEventListener('resize',()=>{ resizeCanvas(); if(canvas && canvas.style.display==='block' && gameInterval) { drawGame(); } });
        document.addEventListener('keydown',handleKeyDown);
        console.log("Base event listeners attached.");
        
        // --- App Initialization ---
        function initializeApp() { 
            console.log("[DEBUG] Initializing app...");
            if (!canvas || !ctx) { console.error("Canvas or context not found during initializeApp! Aborting."); return; }
            const initialColors = generateSnakeColors(2);
            window.nextP1Color = initialColors[0]; window.nextP2Color = initialColors[1];
            if(playAIButton) playAIButton.style.backgroundColor = window.nextP1Color;
            if(play2PButton) play2PButton.style.backgroundColor = window.nextP1Color; 
            if(playBattleButton) playBattleButton.style.backgroundColor = window.nextP1Color;
            if(titleH1) {
                titleH1.style.color = window.nextP2Color;
                titleH1.style.textShadow = `0 0 10px ${window.nextP2Color}, 0 0 20px ${window.nextP2Color}`;
            }
            if(titleScreen) titleScreen.style.display='flex';
            if(gameOverScreen) gameOverScreen.style.display='none';
            if(canvas) canvas.style.display='none';
            if(exitBattleButton) exitBattleButton.style.display = 'none';
            if(recordText) recordText.textContent = `Player 1: ${p1Wins} - AI: ${p2Wins}`; 
            resizeCanvas(); 
            console.log("[DEBUG] App initialized.");
        }
        
        try {
            initializeApp();
        } catch(e) {
            console.error("CRITICAL ERROR during initializeApp call:", e.message, e.stack, e.name);
        }
    </script>
</body>
</html>
